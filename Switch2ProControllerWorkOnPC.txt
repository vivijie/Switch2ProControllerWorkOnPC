import pygame
import time
import threading
import math
from collections import deque
from vgamepad import VX360Gamepad, XUSB_BUTTON

# ==================== é…ç½®åŒºåŸŸ ====================
# é»˜è®¤æ‘‡æ†ç‰©ç†é™åˆ¶æ ¡å‡†ï¼ˆé˜²å‘†è®¾è®¡ï¼Œä½¿ç”¨0.8ä½œä¸ºå®‰å…¨å€¼ï¼‰
DEFAULT_PHYSICAL_LIMITS = {
    'left': {'min_x': -0.8, 'max_x': 0.8, 'min_y': -0.8, 'max_y': 0.8},
    'right': {'min_x': -0.8, 'max_x': 0.8, 'min_y': -0.8, 'max_y': 0.8}
}

# ç‹¬ç«‹æ­»åŒºé…ç½® - å·¦å³æ‘‡æ†åˆ†åˆ«è®¾ç½®
DEADZONE_CONFIG = {
    'left': {
        'deadzone': 0.03,
        'outer_threshold': 0.9,
        'response_curve': 1.0
    },
    'right': {
        'deadzone': 0.03, 
        'outer_threshold': 1.0,
        'response_curve': 1.0
    }
}


# æ‘‡æ†è¾“å‡ºå¢å¹…é…ç½® (1.0=æ— å¢å¹…, 1.1=10%å¢å¹…, 0.9=10%è¡°å‡)
OUTPUT_AMPLIFIER = {
    'left_stick': 1.1,   # å·¦æ‘‡æ†è¾“å‡ºå¢å¹…
    'right_stick': 1.0    # å³æ‘‡æ†è¾“å‡ºå¢å¹…
}


# æ–¹å½¢æ­»åŒºå¼€å…³é…ç½® (0=å…³é—­, 1=å¼€å¯)
SQUARE_DEADZONE_SWITCH = {
    'left_stick': 1,   # å·¦æ‘‡æ†æ–¹å½¢æ­»åŒºå¼€å…³
    'right_stick': 1   # å³æ‘‡æ†æ–¹å½¢æ­»åŒºå¼€å…³
}


# æ›´æ–°ç‡é…ç½®
UPDATE_RATE = 1000  # Hz

# æŒ‰é’®æ˜ å°„
PHYSICAL_TO_NAME = {
    0: "A", 1: "B", 2: "X", 3: "Y",
    4: "R", 5: "ZR", 6: "Plus", 7: "RStick",
    8: "Down", 9: "Right", 10: "Left", 11: "Up",
    12: "L", 13: "ZL", 14: "Min", 15: "LStick",
    16: "Home", 17: "Capture",
    18: "BR", 19: "BL"
}

NAME_TO_XBOX = {
    "BR": XUSB_BUTTON.XUSB_GAMEPAD_B,
    "BL": XUSB_BUTTON.XUSB_GAMEPAD_A,
    "A": XUSB_BUTTON.XUSB_GAMEPAD_A,
    "B": XUSB_BUTTON.XUSB_GAMEPAD_B,
    "X": XUSB_BUTTON.XUSB_GAMEPAD_X,
    "Y": XUSB_BUTTON.XUSB_GAMEPAD_Y,
    "L": XUSB_BUTTON.XUSB_GAMEPAD_LEFT_SHOULDER,
    "R": XUSB_BUTTON.XUSB_GAMEPAD_RIGHT_SHOULDER,
    "Min": XUSB_BUTTON.XUSB_GAMEPAD_BACK,
    "Plus": XUSB_BUTTON.XUSB_GAMEPAD_START,
    "Home": XUSB_BUTTON.XUSB_GAMEPAD_START,
    "Capture": XUSB_BUTTON.XUSB_GAMEPAD_BACK,
    "LStick": XUSB_BUTTON.XUSB_GAMEPAD_LEFT_THUMB,
    "RStick": XUSB_BUTTON.XUSB_GAMEPAD_RIGHT_THUMB,
    "Up": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_UP,
    "Down": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_DOWN,
    "Left": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_LEFT,
    "Right": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_RIGHT,
    "ZL": "left_trigger",
    "ZR": "right_trigger"
}

# ç‰¹æ®ŠæŒ‰é”®é…ç½®
SPECIAL_BUTTONS = {
    17: {'key': 't', 'description': 'CaptureæŒ‰é’®æ˜ å°„ä¸ºé”®ç›˜Té”®'}
}

# ==================== åˆå§‹åŒ– ====================
pygame.init()
pygame.joystick.init()
virtual_gamepad = VX360Gamepad()

joystick_count = pygame.joystick.get_count()
if joystick_count == 0:
    print("æœªæ£€æµ‹åˆ°æ‰‹æŸ„!")
    exit()

joystick = pygame.joystick.Joystick(0)
joystick.init()

print(f"æ£€æµ‹åˆ°æ‰‹æŸ„: {joystick.get_name()}")
print("æŒ‰é’®æ•°é‡:", joystick.get_numbuttons())
print("æŒ‰ Ctrl+C é€€å‡º")

# åˆ›å»ºç‰©ç†åˆ°XBOXçš„æ˜ å°„
PHYSICAL_TO_XBOX = {}
for physical_idx, button_name in PHYSICAL_TO_NAME.items():
    if button_name in NAME_TO_XBOX:
        PHYSICAL_TO_XBOX[physical_idx] = NAME_TO_XBOX[button_name]

# æŒ‰é’®çŠ¶æ€æ•°ç»„
button_states = [False] * 25
trigger_states = {'left': 0.0, 'right': 0.0}

# ==================== æ‘‡æ†èŒƒå›´è‡ªåŠ¨è¯†åˆ«å‡½æ•° ====================
def calibrate_joystick_range():
    """è‡ªåŠ¨è¯†åˆ«æ‘‡æ†ç‰©ç†èŒƒå›´ - åŒæ—¶æ ¡å‡†å·¦å³æ‘‡æ†"""
    print("\n" + "="*60)
    print("ğŸ® æ‘‡æ†èŒƒå›´è‡ªåŠ¨è¯†åˆ«".center(60))
    print("="*60)
    print("è¯·åŒæ—¶è½¬åŠ¨å·¦å³æ‘‡æ†3åœˆï¼Œè¦†ç›–æ‰€æœ‰æ–¹å‘")
    print("ç¡®ä¿æ‘‡æ†ç§»åŠ¨åˆ°å„ä¸ªè§’è½")
    print("10ç§’åè‡ªåŠ¨å®Œæˆæ ¡å‡†")
    print("="*60)
    
    # åˆå§‹åŒ–èŒƒå›´æ•°æ®ï¼ˆä»å½“å‰å€¼å¼€å§‹ï¼Œè€Œä¸æ˜¯é»˜è®¤å€¼ï¼‰
    calibration_data = {
        'left': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0},
        'right': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0}
    }
    
    # æ£€æŸ¥æ‘‡æ†æ•°é‡
    if joystick.get_numaxes() < 4:
        print("é”™è¯¯: æ‘‡æ†è½´æ•°é‡ä¸è¶³ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
        return DEFAULT_PHYSICAL_LIMITS
    
    # å…ˆè¯»å–ä¸€æ¬¡åˆå§‹å€¼æ¥åˆå§‹åŒ–èŒƒå›´
    try:
        pygame.event.pump()
        calibration_data['left']['min_x'] = calibration_data['left']['max_x'] = joystick.get_axis(0)
        calibration_data['left']['min_y'] = calibration_data['left']['max_y'] = joystick.get_axis(1)
        calibration_data['right']['min_x'] = calibration_data['right']['max_x'] = joystick.get_axis(2)
        calibration_data['right']['min_y'] = calibration_data['right']['max_y'] = joystick.get_axis(3)
    except:
        print("åˆå§‹åŒ–è¯»å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
        return DEFAULT_PHYSICAL_LIMITS
    
    print("\nğŸ”„ æ­£åœ¨æ ¡å‡†æ‘‡æ†èŒƒå›´...")
    print("è¯·åŒæ—¶è½¬åŠ¨å·¦å³æ‘‡æ†3åœˆ")
    
    start_time = time.time()
    calibration_time = 10  # æ ¡å‡†æ—¶é—´å¢åŠ åˆ°10ç§’
    
    while time.time() - start_time < calibration_time:
        pygame.event.pump()
        
        try:
            # åŒæ—¶è¯»å–å·¦å³æ‘‡æ†åŸå§‹æ•°æ®
            left_x = joystick.get_axis(0)
            left_y = joystick.get_axis(1)
            right_x = joystick.get_axis(2)
            right_y = joystick.get_axis(3)
            
            # æ›´æ–°å·¦æ‘‡æ†æœ€å°å€¼æœ€å¤§å€¼ - ç›´æ¥æ›´æ–°ï¼Œä¸è®¾é™åˆ¶
            calibration_data['left']['min_x'] = min(calibration_data['left']['min_x'], left_x)
            calibration_data['left']['max_x'] = max(calibration_data['left']['max_x'], left_x)
            calibration_data['left']['min_y'] = min(calibration_data['left']['min_y'], left_y)
            calibration_data['left']['max_y'] = max(calibration_data['left']['max_y'], left_y)
            
            # æ›´æ–°å³æ‘‡æ†æœ€å°å€¼æœ€å¤§å€¼ - ç›´æ¥æ›´æ–°ï¼Œä¸è®¾é™åˆ¶
            calibration_data['right']['min_x'] = min(calibration_data['right']['min_x'], right_x)
            calibration_data['right']['max_x'] = max(calibration_data['right']['max_x'], right_x)
            calibration_data['right']['min_y'] = min(calibration_data['right']['min_y'], right_y)
            calibration_data['right']['max_y'] = max(calibration_data['right']['max_y'], right_y)
            
            # æ˜¾ç¤ºå½“å‰è¿›åº¦
            remaining_time = calibration_time - (time.time() - start_time)
            print(f"\ræ ¡å‡†ä¸­... {remaining_time:.1f}ç§’ å·¦:[X{calibration_data['left']['min_x']:+.3f}â†”{calibration_data['left']['max_x']:+.3f} Y{calibration_data['left']['min_y']:+.3f}â†”{calibration_data['left']['max_y']:+.3f}] å³:[X{calibration_data['right']['min_x']:+.3f}â†”{calibration_data['right']['max_x']:+.3f} Y{calibration_data['right']['min_y']:+.3f}â†”{calibration_data['right']['max_y']:+.3f}]", 
                  end="", flush=True)
            
            time.sleep(0.01)
            
        except Exception as e:
            print(f"\næ ¡å‡†é”™è¯¯: {e}")
            # å‡ºé”™æ—¶ä½¿ç”¨å½“å‰å·²è¯»å–çš„æ•°æ®ï¼Œä¸é€€å›é»˜è®¤å€¼
            break
    
    # éªŒè¯æ ¡å‡†ç»“æœçš„æœ‰æ•ˆæ€§ - æ”¾å®½éªŒè¯æ¡ä»¶
    for stick in ['left', 'right']:
        limits = calibration_data[stick]
        
        # æ£€æŸ¥æ˜¯å¦è¯»å–åˆ°äº†æœ‰æ•ˆæ•°æ®ï¼ˆåªè¦ä¸æ˜¯å…¨0å°±è®¤ä¸ºæœ‰æ•ˆï¼‰
        if (abs(limits['min_x']) < 0.01 and abs(limits['max_x']) < 0.01 and
            abs(limits['min_y']) < 0.01 and abs(limits['max_y']) < 0.01):
            print(f"\nâš ï¸  {stick}æ‘‡æ†æœªæ£€æµ‹åˆ°æœ‰æ•ˆç§»åŠ¨ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
            calibration_data[stick] = DEFAULT_PHYSICAL_LIMITS[stick].copy()
        else:
            # ç¡®ä¿æœ€å°å€¼ç¡®å®å°äºæœ€å¤§å€¼ï¼ˆå¤„ç†åˆå§‹åŒ–é—®é¢˜ï¼‰
            if limits['min_x'] > limits['max_x']:
                limits['min_x'], limits['max_x'] = limits['max_x'], limits['min_x']
            if limits['min_y'] > limits['max_y']:
                limits['min_y'], limits['max_y'] = limits['max_y'], limits['min_y']
    
    print("\n\nâœ… æ‘‡æ†æ ¡å‡†å®Œæˆ!")
    
    # æ˜¾ç¤ºæœ€ç»ˆæ ¡å‡†ç»“æœ
    print("\n" + "="*60)
    print("ğŸ¯ æ ¡å‡†ç»“æœ".center(60))
    print("="*60)
    for stick, limits in calibration_data.items():
        stick_name = "å·¦æ‘‡æ†" if stick == 'left' else "å³æ‘‡æ†"
        print(f"{stick_name}: X[{limits['min_x']:+.3f} â†” {limits['max_x']:+.3f}] "
              f"Y[{limits['min_y']:+.3f} â†” {limits['max_y']:+.3f}]")
    
    print("="*60)
    
    return calibration_data

# ==================== ç»ˆç«¯æ˜¾ç¤ºå‡½æ•° ====================
def print_configuration_info(physical_limits):
    """æ‰“å°æ¼‚äº®çš„é…ç½®ä¿¡æ¯"""
    print("\n" + "="*60)
    print("ğŸ® æ‰‹æŸ„æ˜ å°„é…ç½®ä¿¡æ¯".center(60))
    print("="*60)
    
    # æ­»åŒºé…ç½®æ˜¾ç¤º - å·¦å³ç‹¬ç«‹
    print("\nğŸ“Š æ­»åŒºé…ç½®:")
    for stick in ['left', 'right']:
        stick_name = "å·¦æ‘‡æ†" if stick == 'left' else "å³æ‘‡æ†"
        config = DEADZONE_CONFIG[stick]
        
        deadzone_bar = "[" + "â– " * int(config['deadzone'] * 20) + "â—‹" * (20 - int(config['deadzone'] * 20)) + "]"
        outer_bar = "[" + "â– " * int(config['outer_threshold'] * 20) + "â—‹" * (20 - int(config['outer_threshold'] * 20)) + "]"
        
        print(f"   {stick_name}:")
        print(f"     æ­»åŒº: {config['deadzone']:.3f} {deadzone_bar}")
        print(f"     å¤–ç¯: {config['outer_threshold']:.2f} {outer_bar}")
        print(f"     æ›²çº¿: {config['response_curve']:.1f}")
    
    # æ–¹å½¢æ­»åŒºå¼€å…³æ˜¾ç¤º
    print("\nğŸ”² æ–¹å½¢æ­»åŒºå¼€å…³:")
    left_status = "â–  å¼€å¯" if SQUARE_DEADZONE_SWITCH['left_stick'] else "â–¡ å…³é—­"
    right_status = "â–  å¼€å¯" if SQUARE_DEADZONE_SWITCH['right_stick'] else "â–¡ å…³é—­"
    print(f"   å·¦æ‘‡æ†: {left_status}")
    print(f"   å³æ‘‡æ†: {right_status}")
    
    # è¾“å‡ºå¢å¹…æ˜¾ç¤º
    print("\nğŸ“Š è¾“å‡ºå¢å¹…:")
    left_amp = f"{OUTPUT_AMPLIFIER['left_stick']:.1f}x"
    right_amp = f"{OUTPUT_AMPLIFIER['right_stick']:.1f}x"
    left_amp_bar = "[" + "â– " * int((OUTPUT_AMPLIFIER['left_stick'] - 0.5) * 20) + "â—‹" * (20 - int((OUTPUT_AMPLIFIER['left_stick'] - 0.5) * 20)) + "]"
    right_amp_bar = "[" + "â– " * int((OUTPUT_AMPLIFIER['right_stick'] - 0.5) * 20) + "â—‹" * (20 - int((OUTPUT_AMPLIFIER['right_stick'] - 0.5) * 20)) + "]"
    print(f"   å·¦æ‘‡æ†: {left_amp} {left_amp_bar}")
    print(f"   å³æ‘‡æ†: {right_amp} {right_amp_bar}")
    
    # æ‘‡æ†èŒƒå›´æ˜¾ç¤º
    print("\nğŸ¯ æ‘‡æ†ç‰©ç†èŒƒå›´:")
    for stick, limits in physical_limits.items():
        stick_name = "å·¦æ‘‡æ†" if stick == 'left' else "å³æ‘‡æ†"
        print(f"   {stick_name}: X[{limits['min_x']:+.3f} â†” {limits['max_x']:+.3f}] "
              f"Y[{limits['min_y']:+.3f} â†” {limits['max_y']:+.3f}]")
    
    # æ‘‡æ†æ­»åŒºç¤ºæ„å›¾ - åˆå¹¶æ˜¾ç¤ºå·¦å³æ‘‡æ†
    print("\nğŸ•¹ï¸  æ‘‡æ†æ­»åŒºç¤ºæ„å›¾:")
    
    # å·¦æ‘‡æ†ç¤ºæ„å›¾
    left_config = DEADZONE_CONFIG['left']
    right_config = DEADZONE_CONFIG['right']
    
    print("   " + " " * 10 + "å·¦æ‘‡æ†" + " " * 21 + "å³æ‘‡æ†")
    print("   " + " " * 8 + "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" + " " * 5 + "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("   " + " " * 8 + "â•‘      â†‘      â•‘" + " " * 5 + "â•‘      â†‘      â•‘")
    print("   " + " " * 8 + "â•‘     Y+      â•‘" + " " * 5 + "â•‘     Y+      â•‘")
    print("   " + " " * 5 + "â† X- â•‘     â—‹     â•‘ X+ â†’" + " " * 5 + "â† X- â•‘     â—‹     â•‘ X+ â†’")
    print("   " + " " * 8 + "â•‘     Y-      â•‘" + " " * 5 + "â•‘     Y-      â•‘")
    print("   " + " " * 8 + "â•‘      â†“      â•‘" + " " * 5 + "â•‘      â†“      â•‘")
    print("   " + " " * 8 + "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•" + " " * 5 + "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    # æ­»åŒºèŒƒå›´æ ‡æ³¨ - ç‹¬ç«‹æ˜¾ç¤º
    print(f"   ä¸­å¿ƒæ­»åŒº: {left_config['deadzone']:.3f}" + " " * 18 + f"ä¸­å¿ƒæ­»åŒº: {right_config['deadzone']:.3f}")
    print(f"   å¤–å›´æ­»åŒº: {left_config['outer_threshold']:.2f}" + " " * 18 + f"å¤–å›´æ­»åŒº: {right_config['outer_threshold']:.2f}")
    
    # å½¢çŠ¶æ ‡æ³¨
    left_shape = "æ–¹å½¢" if SQUARE_DEADZONE_SWITCH['left_stick'] else "åœ†å½¢"
    right_shape = "æ–¹å½¢" if SQUARE_DEADZONE_SWITCH['right_stick'] else "åœ†å½¢"
    print(f"   è¾“å‡ºå½¢çŠ¶: {left_shape}" + " " * 20 + f"è¾“å‡ºå½¢çŠ¶: {right_shape}")
    
    # å¢å¹…æ ‡æ³¨
    print(f"   è¾“å‡ºå¢å¹…: {OUTPUT_AMPLIFIER['left_stick']:.1f}x" + " " * 19 + f"è¾“å‡ºå¢å¹…: {OUTPUT_AMPLIFIER['right_stick']:.1f}x")
    
    # æ›´æ–°ç‡æ˜¾ç¤º
    print(f"\nâš¡ æ›´æ–°ç‡: {UPDATE_RATE}Hz")
    
    # ç‰¹æ®ŠæŒ‰é’®æ˜¾ç¤º
    print("\nğŸ”§ ç‰¹æ®ŠåŠŸèƒ½æŒ‰é’®:")
    for btn_id, config in SPECIAL_BUTTONS.items():
        btn_name = PHYSICAL_TO_NAME.get(btn_id, f"Btn{btn_id}")
        print(f"   {btn_name}({btn_id}) â†’ {config['description']}")
    
    # æŒ‰é’®æ˜ å°„æ˜¾ç¤º
    print("\nğŸ¯ æŒ‰é’®æ˜ å°„è¡¨:")
    print("   â•”â•â•â•â•â•â•¦â•â•â•â•â•â•â•¦â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print("   â•‘ ç¼–å· â•‘ åç§° â•‘   æ˜ å°„åˆ°     â•‘")
    print("   â• â•â•â•â•â•â•¬â•â•â•â•â•â•â•¬â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£")
    
    for i in range(min(20, len(PHYSICAL_TO_NAME))):
        if i in PHYSICAL_TO_NAME:
            btn_name = PHYSICAL_TO_NAME[i]
            xbox_map = "æ‰³æœº" if btn_name in ["ZL", "ZR"] else "æŒ‰é’®"
            print(f"   â•‘  {i:2d} â•‘  {btn_name:3s} â•‘ {xbox_map:12s} â•‘")
    
    print("   â•šâ•â•â•â•â•â•©â•â•â•â•â•â•â•©â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    print("\n" + "="*60)
    print("ğŸš€ æ‰‹æŸ„æ˜ å°„å·²å¯åŠ¨ï¼Œå¼€å§‹äº«å—æ¸¸æˆå§ï¼".center(60))
    print("="*60 + "\n")

# ==================== æ‘‡æ†èŒƒå›´ä¼˜åŒ–ç±» ====================
class JoystickRangeOptimizer:
    def __init__(self, physical_limits):
        self.physical_limits = physical_limits
        
    def normalize_joystick_value(self, value, axis_type, stick_type):
        """å°†ç‰©ç†æ‘‡æ†å€¼å½’ä¸€åŒ–åˆ°[-1, 1]èŒƒå›´ - ä½¿ç”¨å‡†ç¡®çš„ç‰©ç†èŒƒå›´"""
        limits = self.physical_limits[stick_type]
        
        if axis_type == 'x':
            # å°†xè½´ä»å®é™…ç‰©ç†èŒƒå›´æ˜ å°„åˆ°[-1, 1]
            if value < 0:
                # è´Ÿæ–¹å‘ï¼šä»[min_x, 0]æ˜ å°„åˆ°[-1, 0]
                if abs(limits['min_x']) > 0.001:  # é¿å…é™¤é›¶
                    normalized = value / abs(limits['min_x'])
                else:
                    normalized = value  # å¦‚æœæœ€å°å€¼ä¸º0ï¼Œç›´æ¥ä½¿ç”¨åŸå€¼
            else:
                # æ­£æ–¹å‘ï¼šä»[0, max_x]æ˜ å°„åˆ°[0, 1]
                if abs(limits['max_x']) > 0.001:  # é¿å…é™¤é›¶
                    normalized = value / limits['max_x']
                else:
                    normalized = value  # å¦‚æœæœ€å¤§å€¼ä¸º0ï¼Œç›´æ¥ä½¿ç”¨åŸå€¼
        else:  # yè½´
            # å°†yè½´ä»å®é™…ç‰©ç†èŒƒå›´æ˜ å°„åˆ°[-1, 1]
            if value < 0:
                # è´Ÿæ–¹å‘ï¼šä»[min_y, 0]æ˜ å°„åˆ°[-1, 0]
                if abs(limits['min_y']) > 0.001:  # é¿å…é™¤é›¶
                    normalized = value / abs(limits['min_y'])
                else:
                    normalized = value  # å¦‚æœæœ€å°å€¼ä¸º0ï¼Œç›´æ¥ä½¿ç”¨åŸå€¼
            else:
                # æ­£æ–¹å‘ï¼šä»[0, max_y]æ˜ å°„åˆ°[0, 1]
                if abs(limits['max_y']) > 0.001:  # é¿å…é™¤é›¶
                    normalized = value / limits['max_y']
                else:
                    normalized = value  # å¦‚æœæœ€å¤§å€¼ä¸º0ï¼Œç›´æ¥ä½¿ç”¨åŸå€¼
                
        # ç¡®ä¿å€¼åœ¨[-1, 1]èŒƒå›´å†…
        return max(-1.0, min(1.0, normalized))

# ==================== æ­»åŒºå¤„ç†ç±» ====================
class AdvancedDeadzone:
    def __init__(self, deadzone_config):
        self.deadzone_config = deadzone_config
    
    def apply_square_deadzone(self, x, y, stick_type):
        """æ–¹å½¢æ­»åŒºå¤„ç† - ç‹¬ç«‹æ§åˆ¶"""
        config = self.deadzone_config[stick_type]
        deadzone = config['deadzone']
        outer_threshold = config['outer_threshold']
        response_curve = config['response_curve']
        
        # è®¡ç®—æœ€å¤§ç»å¯¹å€¼ï¼ˆæ–¹å½¢åŒºåŸŸçš„å…³é”®ï¼‰
        max_abs = max(abs(x), abs(y))
        
        # å¦‚æœæœ€å¤§ç»å¯¹å€¼å°äºæ­»åŒºï¼Œè¿”å›0ï¼ˆåœ¨æ­»åŒºå†…ï¼‰
        if max_abs < deadzone:
            return 0.0, 0.0

        # ç¬¬ä¸€æ­¥ï¼šåº”ç”¨æ–¹å½¢å½¢çŠ¶ï¼ˆå…ˆä¿æŒå®Œæ•´æ–¹å½¢ï¼‰
        if max_abs > 0:
            # è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ - ä¿æŒæ–¹å½¢å½¢çŠ¶
            if abs(x) > 0.0001 or abs(y) > 0.0001:  # é¿å…é™¤é›¶
                # æ‰¾åˆ°ä¸»å¯¼è½´ï¼ˆxæˆ–yä¸­ç»å¯¹å€¼è¾ƒå¤§çš„ï¼‰
                if abs(x) > abs(y):
                    # xè½´ä¸»å¯¼ï¼Œä¿æŒxçš„æ¯”ä¾‹ï¼Œç›¸åº”ç¼©æ”¾y
                    scale = 1.0 / abs(x)  # å…ˆç¼©æ”¾åˆ°å®Œæ•´æ–¹å½¢
                    new_x = math.copysign(1.0, x)
                    new_y = y * scale
                else:
                    # yè½´ä¸»å¯¼ï¼Œä¿æŒyçš„æ¯”ä¾‹ï¼Œç›¸åº”ç¼©æ”¾x
                    scale = 1.0 / abs(y)  # å…ˆç¼©æ”¾åˆ°å®Œæ•´æ–¹å½¢
                    new_x = x * scale
                    new_y = math.copysign(1.0, y)
                
                # ç¡®ä¿ä¸ä¼šè¶…å‡º[-1, 1]èŒƒå›´
                new_x = max(-1.0, min(1.0, new_x))
                new_y = max(-1.0, min(1.0, new_y))
                
                # ç¬¬äºŒæ­¥ï¼šåº”ç”¨å“åº”æ›²çº¿å’ŒèŒƒå›´é™åˆ¶ï¼ˆåå¤„ç†èŒƒå›´ï¼‰
                # è®¡ç®—åŸå§‹è¾“å…¥çš„å¹…åº¦ç”¨äºå“åº”æ›²çº¿
                if response_curve != 1.0:
                    # ä½¿ç”¨åŸå§‹è¾“å…¥çš„å¹…åº¦æ¥è®¡ç®—å“åº”æ›²çº¿
                    normalized = (max_abs - deadzone) / (1.0 - deadzone)
                    scaled_magnitude = normalized ** response_curve
                    final_scale = scaled_magnitude
                else:
                    # çº¿æ€§å“åº”
                    final_scale = (max_abs - deadzone) / (1.0 - deadzone)
                
                # åº”ç”¨å¤–ç¯é˜ˆå€¼é™åˆ¶
                final_scale = min(final_scale, outer_threshold)
                
                # åº”ç”¨æœ€ç»ˆç¼©æ”¾
                new_x *= final_scale
                new_y *= final_scale
                
                return new_x, new_y
        
        return x, y

    def apply_circular_deadzone(self, x, y, stick_type):
        """åœ†å½¢æ­»åŒºå¤„ç† - ç‹¬ç«‹æ§åˆ¶"""
        config = self.deadzone_config[stick_type]
        deadzone = config['deadzone']
        outer_threshold = config['outer_threshold']
        response_curve = config['response_curve']
        
        magnitude = (x**2 + y**2) ** 0.5

        if magnitude < deadzone:
            return 0.0, 0.0

        # åº”ç”¨å“åº”æ›²çº¿
        if response_curve != 1.0:
            normalized = (magnitude - deadzone) / (1.0 - deadzone)
            scaled_magnitude = normalized ** response_curve
            magnitude = scaled_magnitude * (1.0 - deadzone) + deadzone

        # é™åˆ¶æœ€å¤§è¾“å‡º
        magnitude = min(magnitude, outer_threshold)

        # ä¿æŒæ–¹å‘ï¼Œåº”ç”¨ç¼©æ”¾åçš„å¹…åº¦
        if magnitude > 0:
            scale = magnitude / max(magnitude, 0.0001)  # é¿å…é™¤é›¶
            return x * scale, y * scale

        return x, y

# ==================== è¾“å‡ºå¢å¹…å¤„ç†å‡½æ•° ====================
def apply_output_amplifier(x, y, stick_type):
    """åº”ç”¨æ‘‡æ†è¾“å‡ºå¢å¹…"""
    amplifier = OUTPUT_AMPLIFIER[stick_type]
    
    if amplifier != 1.0:
        # è®¡ç®—å½“å‰å¹…åº¦
        current_magnitude = max(abs(x), abs(y))
        
        if current_magnitude > 0:
            # åº”ç”¨å¢å¹…ï¼Œä½†é™åˆ¶åœ¨æœ‰æ•ˆèŒƒå›´å†…
            new_x = x * amplifier
            new_y = y * amplifier
            
            # ç¡®ä¿ä¸è¶…è¿‡[-1, 1]èŒƒå›´
            new_x = max(-1.0, min(1.0, new_x))
            new_y = max(-1.0, min(1.0, new_y))
            
            return new_x, new_y
    
    return x, y

# ==================== ä¸»ç¨‹åº ====================
# è‡ªåŠ¨è¯†åˆ«æ‘‡æ†èŒƒå›´
JOYSTICK_PHYSICAL_LIMITS = calibrate_joystick_range()

# åˆå§‹åŒ–å¤„ç†å™¨ - ä¼ å…¥ç‹¬ç«‹é…ç½®
deadzone_processor = AdvancedDeadzone(DEADZONE_CONFIG)
joystick_optimizer = JoystickRangeOptimizer(JOYSTICK_PHYSICAL_LIMITS)

# æ‘‡æ†æ•°æ®ç¼“å­˜
stick_data_cache = {
    'left': {'x': 0.0, 'y': 0.0},
    'right': {'x': 0.0, 'y': 0.0}
}

# é«˜ç²¾åº¦å®šæ—¶å™¨
last_update_time = time.perf_counter()
update_interval = 1.0 / UPDATE_RATE

# ==================== å¤„ç†å‡½æ•° ====================
def process_joysticks_optimized(joystick):
    """ä¼˜åŒ–çš„æ‘‡æ†å¤„ç†ï¼ŒåŒ…æ‹¬èŒƒå›´å½’ä¸€åŒ–"""
    global stick_data_cache

    if joystick.get_numaxes() < 4:
        return

    try:
        # è¯»å–åŸå§‹æ‘‡æ†æ•°æ®
        left_x = joystick.get_axis(0)
        left_y = joystick.get_axis(1)
        right_x = joystick.get_axis(2)
        right_y = joystick.get_axis(3)

        # åº”ç”¨èŒƒå›´å½’ä¸€åŒ– - ä½¿ç”¨å‡†ç¡®çš„ç‰©ç†èŒƒå›´æ˜ å°„åˆ°[-1, 1]
        left_x = joystick_optimizer.normalize_joystick_value(left_x, 'x', 'left')
        left_y = joystick_optimizer.normalize_joystick_value(left_y, 'y', 'left')
        right_x = joystick_optimizer.normalize_joystick_value(right_x, 'x', 'right')
        right_y = joystick_optimizer.normalize_joystick_value(right_y, 'y', 'right')

        # åº”ç”¨æ­»åŒºç®—æ³• - æ ¹æ®å¼€å…³é€‰æ‹©æ–¹å½¢æˆ–åœ†å½¢æ­»åŒºï¼Œç‹¬ç«‹æ§åˆ¶
        if SQUARE_DEADZONE_SWITCH['left_stick']:
            left_x, left_y = deadzone_processor.apply_square_deadzone(left_x, left_y, 'left')
        else:
            left_x, left_y = deadzone_processor.apply_circular_deadzone(left_x, left_y, 'left')
            
        if SQUARE_DEADZONE_SWITCH['right_stick']:
            right_x, right_y = deadzone_processor.apply_square_deadzone(right_x, right_y, 'right')
        else:
            right_x, right_y = deadzone_processor.apply_circular_deadzone(right_x, right_y, 'right')

        # åº”ç”¨è¾“å‡ºå¢å¹… - æ–°å¢æ­¥éª¤
        left_x, left_y = apply_output_amplifier(left_x, left_y, 'left_stick')
        right_x, right_y = apply_output_amplifier(right_x, right_y, 'right_stick')

        # æ›´æ–°ç¼“å­˜
        stick_data_cache['left']['x'] = left_x
        stick_data_cache['left']['y'] = left_y
        stick_data_cache['right']['x'] = right_x
        stick_data_cache['right']['y'] = right_y

    except Exception as e:
        print(f"æ‘‡æ†è¯»å–é”™è¯¯: {e}")

def process_trigger_buttons():
    """å¤„ç†æ‰³æœºæŒ‰é’®ï¼ˆæŒ‰é’®5å’Œ13ï¼‰"""
    global trigger_states

    try:
        # å³æ‰³æœºæŒ‰é’® (ZR - æŒ‰é’®5)
        zr_pressed = bool(joystick.get_button(5))
        trigger_states['right'] = 1.0 if zr_pressed else 0.0

        # å·¦æ‰³æœºæŒ‰é’® (ZL - æŒ‰é’®13)
        zl_pressed = bool(joystick.get_button(13))
        trigger_states['left'] = 1.0 if zl_pressed else 0.0

    except Exception as e:
        print(f"æ‰³æœºæŒ‰é’®è¯»å–é”™è¯¯: {e}")

def update_virtual_gamepad():
    """é«˜é€Ÿæ›´æ–°è™šæ‹Ÿæ‰‹æŸ„"""
    global last_update_time

    while True:
        current_time = time.perf_counter()
        elapsed = current_time - last_update_time

        if elapsed >= update_interval:
            try:
                # è®¾ç½®æ‘‡æ†
                left = stick_data_cache['left']
                right = stick_data_cache['right']

                virtual_gamepad.left_joystick_float(left['x'], left['y'])
                virtual_gamepad.right_joystick_float(right['x'], right['y'])

                # è®¾ç½®æ‰³æœº
                virtual_gamepad.left_trigger_float(trigger_states['left'])
                virtual_gamepad.right_trigger_float(trigger_states['right'])

                virtual_gamepad.update()
                last_update_time = current_time

            except Exception as e:
                print(f"è™šæ‹Ÿæ‰‹æŸ„æ›´æ–°é”™è¯¯: {e}")

        time.sleep(0.001)

# å¯åŠ¨é«˜é€Ÿæ›´æ–°çº¿ç¨‹
update_thread = threading.Thread(target=update_virtual_gamepad, daemon=True)
update_thread.start()

# æ£€æŸ¥pyautoguiå¯ç”¨æ€§
try:
    import pyautogui
    USE_PYAUTOGUI = True
    print("ä½¿ç”¨pyautoguiè¿›è¡Œé”®ç›˜æ¨¡æ‹Ÿ")
except ImportError:
    USE_PYAUTOGUI = False
    print("pyautoguiæœªå®‰è£…ï¼Œä½¿ç”¨pygameäº‹ä»¶æ¨¡æ‹Ÿ")
    print("å®‰è£…pyautogui: pip install pyautogui")

# æ‰“å°é…ç½®ä¿¡æ¯
print_configuration_info(JOYSTICK_PHYSICAL_LIMITS)

try:
    print(f"ä¼˜åŒ–ç‰ˆæ‰‹æŸ„æ˜ å°„å·²å¯åŠ¨ï¼ˆ{UPDATE_RATE}Hz æ›´æ–°ç‡ï¼‰")
    print("æ‘‡æ†èŒƒå›´å·²è‡ªåŠ¨è¯†åˆ«ï¼Œç‰©ç†é™åˆ¶å·²è¡¥å¿")
    
    # æ˜¾ç¤ºç‹¬ç«‹æ­»åŒºé…ç½®
    left_config = DEADZONE_CONFIG['left']
    right_config = DEADZONE_CONFIG['right']
    print(f"å·¦æ‘‡æ†æ­»åŒº: {left_config['deadzone']:.3f}, å¤–ç¯: {left_config['outer_threshold']:.2f}, æ›²çº¿: {left_config['response_curve']:.1f}")
    print(f"å³æ‘‡æ†æ­»åŒº: {right_config['deadzone']:.3f}, å¤–ç¯: {right_config['outer_threshold']:.2f}, æ›²çº¿: {right_config['response_curve']:.1f}")
    
    # æ˜¾ç¤ºæ–¹å½¢æ­»åŒºçŠ¶æ€
    left_status = "å¼€å¯" if SQUARE_DEADZONE_SWITCH['left_stick'] else "å…³é—­"
    right_status = "å¼€å¯" if SQUARE_DEADZONE_SWITCH['right_stick'] else "å…³é—­"
    print(f"å·¦æ‘‡æ†æ–¹å½¢æ­»åŒº: {left_status}")
    print(f"å³æ‘‡æ†æ–¹å½¢æ­»åŒº: {right_status}")
    
    # æ˜¾ç¤ºè¾“å‡ºå¢å¹…çŠ¶æ€
    print(f"å·¦æ‘‡æ†è¾“å‡ºå¢å¹…: {OUTPUT_AMPLIFIER['left_stick']:.1f}x")
    print(f"å³æ‘‡æ†è¾“å‡ºå¢å¹…: {OUTPUT_AMPLIFIER['right_stick']:.1f}x")
    
    print("æ‰³æœºæŒ‰é’®: ZL=æŒ‰é’®13, ZR=æŒ‰é’®5")
    
    # æ‰“å°ç‰¹æ®ŠæŒ‰é’®é…ç½®
    for btn_id, config in SPECIAL_BUTTONS.items():
        print(f"æŒ‰é’®{btn_id}: {config['description']}")

    while True:
        pygame.event.pump()

        # å¤„ç†æ‰€æœ‰æŒ‰é’®
        num_buttons = min(joystick.get_numbuttons(), 25)
        for i in range(num_buttons):
            try:
                current_state = bool(joystick.get_button(i))
            except:
                current_state = False

            if current_state != button_states[i]:
                button_name = PHYSICAL_TO_NAME.get(i, f"Btn{i}")

                # ç‰¹æ®ŠæŒ‰é’®å¤„ç†ï¼ˆå¦‚CaptureæŒ‰é’®ï¼‰
                if i in SPECIAL_BUTTONS:
                    config = SPECIAL_BUTTONS[i]
                    if current_state:
                        # æŒ‰ä¸‹ç‰¹æ®ŠæŒ‰é’®
                        if USE_PYAUTOGUI:
                            pyautogui.keyDown(config['key'])
                        else:
                            key_event = pygame.event.Event(pygame.KEYDOWN, key=getattr(pygame, f"K_{config['key']}"))
                            pygame.event.post(key_event)
                        print(f"æŒ‰ä¸‹: {button_name} -> é”®ç›˜{config['key'].upper()}é”®æŒ‰ä¸‹")
                    else:
                        # é‡Šæ”¾ç‰¹æ®ŠæŒ‰é’®
                        if USE_PYAUTOGUI:
                            pyautogui.keyUp(config['key'])
                        else:
                            key_event = pygame.event.Event(pygame.KEYUP, key=getattr(pygame, f"K_{config['key']}"))
                            pygame.event.post(key_event)
                        print(f"é‡Šæ”¾: {button_name} -> é”®ç›˜{config['key'].upper()}é”®é‡Šæ”¾")
                    
                    button_states[i] = current_state
                    continue

                # æ™®é€šæŒ‰é’®å¤„ç†
                if i in PHYSICAL_TO_XBOX:
                    target = PHYSICAL_TO_XBOX[i]

                    if isinstance(target, XUSB_BUTTON):
                        # æ™®é€šæŒ‰é’®
                        if current_state:
                            virtual_gamepad.press_button(target)
                            print(f"æŒ‰ä¸‹: {button_name}")
                        else:
                            virtual_gamepad.release_button(target)
                            print(f"é‡Šæ”¾: {button_name}")

                    elif isinstance(target, str) and target in ['left_trigger', 'right_trigger']:
                        # æ‰³æœºæŒ‰é’®ï¼ˆç‰¹æ®Šå¤„ç†ï¼‰
                        if current_state:
                            print(f"æŒ‰ä¸‹æ‰³æœº: {button_name}")
                        else:
                            print(f"é‡Šæ”¾æ‰³æœº: {button_name}")

                button_states[i] = current_state

        # å¤„ç†pygameäº‹ä»¶é˜Ÿåˆ—ï¼ˆå¦‚æœä½¿ç”¨pygameæ¨¡æ‹Ÿï¼‰
        if not USE_PYAUTOGUI:
            for event in pygame.event.get():
                # è®©pygameå¤„ç†æˆ‘ä»¬å‘é€çš„é”®ç›˜äº‹ä»¶
                if event.type in (pygame.KEYDOWN, pygame.KEYUP):
                    pass

        # å¤„ç†æ‰³æœºæŒ‰é’®çŠ¶æ€
        process_trigger_buttons()

        # å¤„ç†æ‘‡æ†
        process_joysticks_optimized(joystick)

        time.sleep(0.001)

except KeyboardInterrupt:
    virtual_gamepad.reset()
    virtual_gamepad.update()
    pygame.quit()
    print("\nğŸ® ç¨‹åºå·²é€€å‡ºï¼Œæ„Ÿè°¢ä½¿ç”¨ï¼")