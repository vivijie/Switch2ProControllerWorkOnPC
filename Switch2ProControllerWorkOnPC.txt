import pygame
import time
import threading
import math
from collections import deque
from vgamepad import VX360Gamepad, XUSB_BUTTON

# ==================== é…ç½®åŒºåŸŸ ====================
# ä¸€è‡´æ€§æ¨¡å¼é…ç½® (global_min: å…¨å±€æœ€å°èŒƒå›´ç»Ÿä¸€ç¼©æ”¾, independent: ä¼ ç»Ÿç‹¬ç«‹ç¼©æ”¾)
CONSISTENCY_MODE = {
    'left': 'global_min',   # å·¦æ‘‡æ†ä½¿ç”¨ä¸€è‡´æ€§æ¨¡å¼
    'right': 'global_min'   # å³æ‘‡æ†ä½¿ç”¨ä¸€è‡´æ€§æ¨¡å¼
}

# é»˜è®¤æ‘‡æ†ç‰©ç†é™åˆ¶æ ¡å‡†ï¼ˆé˜²å‘†è®¾è®¡ï¼Œä½¿ç”¨0.8ä½œä¸ºå®‰å…¨å€¼ï¼‰
DEFAULT_PHYSICAL_LIMITS = {
    'left': {'min_x': -0.8, 'max_x': 0.8, 'min_y': -0.8, 'max_y': 0.8},
    'right': {'min_x': -0.8, 'max_x': 0.8, 'min_y': -0.8, 'max_y': 0.8}
}

# é»˜è®¤æ‘‡æ†ä¸­å¿ƒåç§»æ ¡å‡†
DEFAULT_CENTER_OFFSETS = {
    'left': {'x': 0.0, 'y': 0.0},
    'right': {'x': 0.0, 'y': 0.0}
}

# ç‹¬ç«‹æ­»åŒºé…ç½® - å·¦å³æ‘‡æ†åˆ†åˆ«è®¾ç½®
DEADZONE_CONFIG = {
    'left': {
        'deadzone': 0.03,
        'outer_threshold': 1.0,
        'response_curve': 1.0
    },
    'right': {
        'deadzone': 0.00, 
        'outer_threshold': 1.0,
        'response_curve': 1.0
    }
}

# æ‘‡æ†è¾“å‡ºå¢å¹…é…ç½® (1.0=æ— å¢å¹…, 1.1=10%å¢å¹…, 0.9=10%è¡°å‡)
OUTPUT_AMPLIFIER = {
    'left_stick': 1.0,   # å·¦æ‘‡æ†è¾“å‡ºå¢å¹…
    'right_stick': 1.0    # å³æ‘‡æ†è¾“å‡ºå¢å¹…
}

# æ–¹å½¢æ­»åŒºå¼€å…³é…ç½® (0=å…³é—­, 1=å¼€å¯)
SQUARE_DEADZONE_SWITCH = {
    'left_stick': 1,   # å·¦æ‘‡æ†æ–¹å½¢æ­»åŒºå¼€å…³
    'right_stick': 1   # å³æ‘‡æ†æ–¹å½¢æ­»åŒºå¼€å…³
}

# æ–¹å½¢æ˜ å°„å¼ºåº¦é…ç½® (0.0=çº¯åœ†, 1.0=çº¯æ–¹, ä¸­é—´å€¼=æ··åˆ)
SQUARE_MAPPING_STRENGTH = {
    'left_stick': 0.5,   # å·¦æ‘‡æ†æ–¹å½¢æ˜ å°„å¼ºåº¦
    'right_stick': 0.5   # å³æ‘‡æ†æ–¹å½¢æ˜ å°„å¼ºåº¦
}

# æ›´æ–°ç‡é…ç½®
UPDATE_RATE = 2000  # Hz

# æŒ‰é’®æ˜ å°„
PHYSICAL_TO_NAME = {
    0: "A", 1: "B", 2: "X", 3: "Y",
    4: "R", 5: "ZR", 6: "Plus", 7: "RStick",
    8: "Down", 9: "Right", 10: "Left", 11: "Up",
    12: "L", 13: "ZL", 14: "Min", 15: "LStick",
    16: "Home", 17: "Capture",
    18: "BR", 19: "BL",
    20: "C"
}

NAME_TO_XBOX = {
    "BR": XUSB_BUTTON.XUSB_GAMEPAD_B,
    "BL": XUSB_BUTTON.XUSB_GAMEPAD_A,
    "A": XUSB_BUTTON.XUSB_GAMEPAD_A,
    "B": XUSB_BUTTON.XUSB_GAMEPAD_B,
    "X": XUSB_BUTTON.XUSB_GAMEPAD_X,
    "Y": XUSB_BUTTON.XUSB_GAMEPAD_Y,
    "L": XUSB_BUTTON.XUSB_GAMEPAD_LEFT_SHOULDER,
    "R": XUSB_BUTTON.XUSB_GAMEPAD_RIGHT_SHOULDER,
    "Min": XUSB_BUTTON.XUSB_GAMEPAD_BACK,
    "Plus": XUSB_BUTTON.XUSB_GAMEPAD_START,
    "Home": XUSB_BUTTON.XUSB_GAMEPAD_START,
    "Capture": XUSB_BUTTON.XUSB_GAMEPAD_BACK,
    "LStick": XUSB_BUTTON.XUSB_GAMEPAD_LEFT_THUMB,
    "RStick": XUSB_BUTTON.XUSB_GAMEPAD_RIGHT_THUMB,
    "Up": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_UP,
    "Down": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_DOWN,
    "Left": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_LEFT,
    "Right": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_RIGHT,
    "ZL": "left_trigger",
    "ZR": "right_trigger"
}

# ç‰¹æ®ŠæŒ‰é”®é…ç½® - ä¿®æ”¹ä¸ºç»Ÿä¸€ä½¿ç”¨keysåˆ—è¡¨
SPECIAL_BUTTONS = {
    17: {'keys': ['t'], 'description': 'CaptureæŒ‰é’®æ˜ å°„ä¸ºé”®ç›˜Té”®'},
    20: {'keys': ['alt', 'f10'], 'description': 'HomeæŒ‰é’®æ˜ å°„ä¸ºAlt+F10ç»„åˆé”®'}
}

# ==================== åˆå§‹åŒ– ====================
pygame.init()
pygame.joystick.init()
virtual_gamepad = VX360Gamepad()

joystick_count = pygame.joystick.get_count()
if joystick_count == 0:
    print("æœªæ£€æµ‹åˆ°æ‰‹æŸ„!")
    exit()

joystick = pygame.joystick.Joystick(0)
joystick.init()

print(f"æ£€æµ‹åˆ°æ‰‹æŸ„: {joystick.get_name()}")
print("æŒ‰é’®æ•°é‡:", joystick.get_numbuttons())
print("æŒ‰ Ctrl+C é€€å‡º")

# åˆ›å»ºç‰©ç†åˆ°XBOXçš„æ˜ å°„
PHYSICAL_TO_XBOX = {}
for physical_idx, button_name in PHYSICAL_TO_NAME.items():
    if button_name in NAME_TO_XBOX:
        PHYSICAL_TO_XBOX[physical_idx] = NAME_TO_XBOX[button_name]

# æŒ‰é’®çŠ¶æ€æ•°ç»„
button_states = [False] * 25
trigger_states = {'left': 0.0, 'right': 0.0}

# ==================== ä¿®æ­£çš„æ‘‡æ†èŒƒå›´è‡ªåŠ¨è¯†åˆ«å‡½æ•° ====================
def calibrate_joystick_range_and_center():
    """ä¿®æ­£çš„æ‘‡æ†æ ¡å‡†ï¼šå…ˆæ ¡å‡†ä¸­å¿ƒç‚¹ï¼Œå†è®¡ç®—æ ¡å‡†åçš„å®é™…èŒƒå›´"""
    print("\n" + "="*80)
    print("ğŸ® ä¿®æ­£ç‰ˆæ‘‡æ†èŒƒå›´ä¸ä¸­å¿ƒåç§»è‡ªåŠ¨è¯†åˆ«".center(80))
    print("="*80)
    print("ç¬¬ä¸€æ­¥: è¯·å°†å·¦å³æ‘‡æ†ä¿æŒåœ¨ä¸­å¿ƒä½ç½®ï¼Œä¸è¦è§¦ç¢°")
    print("ç¬¬äºŒæ­¥: 10ç§’åå¼€å§‹èŒƒå›´æ ¡å‡†ï¼Œè¯·åŒæ—¶è½¬åŠ¨å·¦å³æ‘‡æ†3åœˆï¼Œè¦†ç›–æ‰€æœ‰æ–¹å‘")
    print("="*80)
    
    # åˆå§‹åŒ–èŒƒå›´æ•°æ®ï¼ˆå­˜å‚¨åŸå§‹ç‰©ç†èŒƒå›´ï¼‰
    raw_physical_limits = {
        'left': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0},
        'right': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0}
    }
    
    # åˆå§‹åŒ–æ ¡å‡†åçš„èŒƒå›´æ•°æ®ï¼ˆåº”ç”¨ä¸­å¿ƒåç§»åçš„å®é™…èŒƒå›´ï¼‰
    calibrated_physical_limits = {
        'left': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0},
        'right': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0}
    }
    
    # åˆå§‹åŒ–ä¸­å¿ƒåç§»æ•°æ®
    center_offsets = {
        'left': {'x': 0.0, 'y': 0.0},
        'right': {'x': 0.0, 'y': 0.0}
    }
    
    # æ£€æŸ¥æ‘‡æ†æ•°é‡
    if joystick.get_numaxes() < 4:
        print("é”™è¯¯: æ‘‡æ†è½´æ•°é‡ä¸è¶³ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
        return DEFAULT_PHYSICAL_LIMITS, DEFAULT_CENTER_OFFSETS
    
    # ==================== ç¬¬ä¸€æ­¥: æ£€æµ‹ä¸­å¿ƒåç§» ====================
    print("\nğŸ“Š æ­£åœ¨æ£€æµ‹æ‘‡æ†ä¸­å¿ƒåç§»...")
    print("è¯·ç¡®ä¿å·¦å³æ‘‡æ†éƒ½ä¿æŒåœ¨ä¸­å¿ƒä½ç½®ï¼Œä¸è¦è§¦ç¢°")
    time.sleep(3)  # ç­‰å¾…3ç§’è®©ç”¨æˆ·å‡†å¤‡
    
    center_samples = {'left': {'x': [], 'y': []}, 'right': {'x': [], 'y': []}}
    sample_count = 100
    sample_interval = 0.01
    
    for i in range(sample_count):
        pygame.event.pump()
        
        try:
            # è¯»å–æ‘‡æ†åŸå§‹æ•°æ®
            left_x = joystick.get_axis(0)
            left_y = joystick.get_axis(1)
            right_x = joystick.get_axis(2)
            right_y = joystick.get_axis(3)
            
            # æ”¶é›†æ ·æœ¬
            center_samples['left']['x'].append(left_x)
            center_samples['left']['y'].append(left_y)
            center_samples['right']['x'].append(right_x)
            center_samples['right']['y'].append(right_y)
            
            # æ˜¾ç¤ºè¿›åº¦
            progress = (i + 1) / sample_count * 100
            print(f"\ré‡‡é›†ä¸­å¿ƒæ ·æœ¬: {progress:.0f}%", end="", flush=True)
            
            time.sleep(sample_interval)
            
        except Exception as e:
            print(f"\né‡‡é›†ä¸­å¿ƒæ ·æœ¬é”™è¯¯: {e}")
    
    # è®¡ç®—ä¸­å¿ƒåç§»ï¼ˆå¹³å‡å€¼ï¼‰
    for stick in ['left', 'right']:
        center_offsets[stick]['x'] = sum(center_samples[stick]['x']) / sample_count
        center_offsets[stick]['y'] = sum(center_samples[stick]['y']) / sample_count
    
    print(f"\n\nâœ… ä¸­å¿ƒåç§»æ£€æµ‹å®Œæˆ!")
    print(f"å·¦æ‘‡æ†ä¸­å¿ƒåç§»: X={center_offsets['left']['x']:+.4f}, Y={center_offsets['left']['y']:+.4f}")
    print(f"å³æ‘‡æ†ä¸­å¿ƒåç§»: X={center_offsets['right']['x']:+.4f}, Y={center_offsets['right']['y']:+.4f}")
    
    # ==================== ç¬¬äºŒæ­¥: æ£€æµ‹ç‰©ç†èŒƒå›´ï¼ˆåº”ç”¨ä¸­å¿ƒåç§»å‰ï¼‰ ====================
    print("\nğŸ”„ æ­£åœ¨æ ¡å‡†æ‘‡æ†ç‰©ç†èŒƒå›´...")
    print("è¯·åŒæ—¶è½¬åŠ¨å·¦å³æ‘‡æ†3åœˆï¼Œè¦†ç›–æ‰€æœ‰æ–¹å‘")
    time.sleep(2)  # ç­‰å¾…2ç§’
    
    # ä½¿ç”¨åŸå§‹å€¼åˆå§‹åŒ–èŒƒå›´ï¼ˆä¸åº”ç”¨ä¸­å¿ƒåç§»ï¼‰
    try:
        pygame.event.pump()
        # è¯»å–åŸå§‹å€¼ï¼ˆä¸åº”ç”¨ä¸­å¿ƒåç§»ï¼‰
        left_x = joystick.get_axis(0)
        left_y = joystick.get_axis(1)
        right_x = joystick.get_axis(2)
        right_y = joystick.get_axis(3)
        
        raw_physical_limits['left']['min_x'] = raw_physical_limits['left']['max_x'] = left_x
        raw_physical_limits['left']['min_y'] = raw_physical_limits['left']['max_y'] = left_y
        raw_physical_limits['right']['min_x'] = raw_physical_limits['right']['max_x'] = right_x
        raw_physical_limits['right']['min_y'] = raw_physical_limits['right']['max_y'] = right_y
        
        # åŒæ—¶åˆå§‹åŒ–æ ¡å‡†åçš„èŒƒå›´ï¼ˆåº”ç”¨ä¸­å¿ƒåç§»ï¼‰
        calibrated_left_x = left_x - center_offsets['left']['x']
        calibrated_left_y = left_y - center_offsets['left']['y']
        calibrated_right_x = right_x - center_offsets['right']['x']
        calibrated_right_y = right_y - center_offsets['right']['y']
        
        calibrated_physical_limits['left']['min_x'] = calibrated_physical_limits['left']['max_x'] = calibrated_left_x
        calibrated_physical_limits['left']['min_y'] = calibrated_physical_limits['left']['max_y'] = calibrated_left_y
        calibrated_physical_limits['right']['min_x'] = calibrated_physical_limits['right']['max_x'] = calibrated_right_x
        calibrated_physical_limits['right']['min_y'] = calibrated_physical_limits['right']['max_y'] = calibrated_right_y
        
    except:
        print("åˆå§‹åŒ–è¯»å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
        return DEFAULT_PHYSICAL_LIMITS, center_offsets
    
    start_time = time.time()
    calibration_time = 6  # æ ¡å‡†æ—¶é—´6ç§’
    
    while time.time() - start_time < calibration_time:
        pygame.event.pump()
        
        try:
            # è¯»å–åŸå§‹æ•°æ®ï¼ˆä¸åº”ç”¨ä¸­å¿ƒåç§»ï¼‰
            left_x = joystick.get_axis(0)
            left_y = joystick.get_axis(1)
            right_x = joystick.get_axis(2)
            right_y = joystick.get_axis(3)
            
            # æ›´æ–°åŸå§‹ç‰©ç†èŒƒå›´
            raw_physical_limits['left']['min_x'] = min(raw_physical_limits['left']['min_x'], left_x)
            raw_physical_limits['left']['max_x'] = max(raw_physical_limits['left']['max_x'], left_x)
            raw_physical_limits['left']['min_y'] = min(raw_physical_limits['left']['min_y'], left_y)
            raw_physical_limits['left']['max_y'] = max(raw_physical_limits['left']['max_y'], left_y)
            
            raw_physical_limits['right']['min_x'] = min(raw_physical_limits['right']['min_x'], right_x)
            raw_physical_limits['right']['max_x'] = max(raw_physical_limits['right']['max_x'], right_x)
            raw_physical_limits['right']['min_y'] = min(raw_physical_limits['right']['min_y'], right_y)
            raw_physical_limits['right']['max_y'] = max(raw_physical_limits['right']['max_y'], right_y)
            
            # åŒæ—¶æ›´æ–°æ ¡å‡†åçš„èŒƒå›´ï¼ˆåº”ç”¨ä¸­å¿ƒåç§»ï¼‰
            calibrated_left_x = left_x - center_offsets['left']['x']
            calibrated_left_y = left_y - center_offsets['left']['y']
            calibrated_right_x = right_x - center_offsets['right']['x']
            calibrated_right_y = right_y - center_offsets['right']['y']
            
            calibrated_physical_limits['left']['min_x'] = min(calibrated_physical_limits['left']['min_x'], calibrated_left_x)
            calibrated_physical_limits['left']['max_x'] = max(calibrated_physical_limits['left']['max_x'], calibrated_left_x)
            calibrated_physical_limits['left']['min_y'] = min(calibrated_physical_limits['left']['min_y'], calibrated_left_y)
            calibrated_physical_limits['left']['max_y'] = max(calibrated_physical_limits['left']['max_y'], calibrated_left_y)
            
            calibrated_physical_limits['right']['min_x'] = min(calibrated_physical_limits['right']['min_x'], calibrated_right_x)
            calibrated_physical_limits['right']['max_x'] = max(calibrated_physical_limits['right']['max_x'], calibrated_right_x)
            calibrated_physical_limits['right']['min_y'] = min(calibrated_physical_limits['right']['min_y'], calibrated_right_y)
            calibrated_physical_limits['right']['max_y'] = max(calibrated_physical_limits['right']['max_y'], calibrated_right_y)
            
            # æ˜¾ç¤ºå½“å‰è¿›åº¦ï¼ˆæ˜¾ç¤ºæ ¡å‡†åçš„èŒƒå›´ï¼‰
            remaining_time = calibration_time - (time.time() - start_time)
            print(f"\ræ ¡å‡†ä¸­... {remaining_time:.1f}ç§’ å·¦:[X{calibrated_physical_limits['left']['min_x']:+.3f}â†”{calibrated_physical_limits['left']['max_x']:+.3f} Y{calibrated_physical_limits['left']['min_y']:+.3f}â†”{calibrated_physical_limits['left']['max_y']:+.3f}] å³:[X{calibrated_physical_limits['right']['min_x']:+.3f}â†”{calibrated_physical_limits['right']['max_x']:+.3f} Y{calibrated_physical_limits['right']['min_y']:+.3f}â†”{calibrated_physical_limits['right']['max_y']:+.3f}]", 
                  end="", flush=True)
            
            time.sleep(0.01)
            
        except Exception as e:
            print(f"\næ ¡å‡†é”™è¯¯: {e}")
            break
    
    # éªŒè¯æ ¡å‡†ç»“æœçš„æœ‰æ•ˆæ€§
    for stick in ['left', 'right']:
        raw_limits = raw_physical_limits[stick]
        calibrated_limits = calibrated_physical_limits[stick]
        
        # æ£€æŸ¥æ˜¯å¦è¯»å–åˆ°äº†æœ‰æ•ˆæ•°æ®
        if (abs(calibrated_limits['min_x']) < 0.01 and abs(calibrated_limits['max_x']) < 0.01 and
            abs(calibrated_limits['min_y']) < 0.01 and abs(calibrated_limits['max_y']) < 0.01):
            print(f"\nâš ï¸  {stick}æ‘‡æ†æœªæ£€æµ‹åˆ°æœ‰æ•ˆç§»åŠ¨ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´")
            calibrated_physical_limits[stick] = DEFAULT_PHYSICAL_LIMITS[stick].copy()
        else:
            # ç¡®ä¿æœ€å°å€¼ç¡®å®å°äºæœ€å¤§å€¼
            if calibrated_limits['min_x'] > calibrated_limits['max_x']:
                calibrated_limits['min_x'], calibrated_limits['max_x'] = calibrated_limits['max_x'], calibrated_limits['min_x']
            if calibrated_limits['min_y'] > calibrated_limits['max_y']:
                calibrated_limits['min_y'], calibrated_limits['max_y'] = calibrated_limits['max_y'], calibrated_limits['min_y']
    
    print("\n\nâœ… æ‘‡æ†æ ¡å‡†å®Œæˆ!")
    
    # æ˜¾ç¤ºæœ€ç»ˆæ ¡å‡†ç»“æœï¼ˆå¯¹æ¯”åŸå§‹å’Œæ ¡å‡†åçš„èŒƒå›´ï¼‰
    print("\n" + "="*80)
    print("ğŸ¯ æ ¡å‡†ç»“æœå¯¹æ¯”".center(80))
    print("="*80)
    for stick in ['left', 'right']:
        stick_name = "å·¦æ‘‡æ†" if stick == 'left' else "å³æ‘‡æ†"
        raw_limits = raw_physical_limits[stick]
        calibrated_limits = calibrated_physical_limits[stick]
        offset = center_offsets[stick]
        
        print(f"{stick_name}:")
        print(f"  åŸå§‹èŒƒå›´:   X[{raw_limits['min_x']:+.3f} â†” {raw_limits['max_x']:+.3f}] Y[{raw_limits['min_y']:+.3f} â†” {raw_limits['max_y']:+.3f}]")
        print(f"  æ ¡å‡†åèŒƒå›´: X[{calibrated_limits['min_x']:+.3f} â†” {calibrated_limits['max_x']:+.3f}] Y[{calibrated_limits['min_y']:+.3f} â†” {calibrated_limits['max_y']:+.3f}]")
        print(f"  ä¸­å¿ƒåç§»:   X={offset['x']:+.4f}, Y={offset['y']:+.4f}")
    print("="*80)
    
    return calibrated_physical_limits, center_offsets

# ==================== ä¿®æ­£çš„ä¸€è‡´æ€§ä¼˜å…ˆæ‘‡æ†ä¼˜åŒ–å™¨ ====================
class CorrectedConsistentJoystickOptimizer:
    def __init__(self, calibrated_physical_limits, center_offsets, consistency_mode):
        """
        ä¿®æ­£çš„ä¼˜åŒ–å™¨ï¼šä½¿ç”¨æ ¡å‡†åçš„ç‰©ç†èŒƒå›´è¿›è¡Œè®¡ç®—
        calibrated_physical_limits: å·²ç»åº”ç”¨ä¸­å¿ƒåç§»æ ¡æ­£åçš„ç‰©ç†èŒƒå›´
        center_offsets: ä¸­å¿ƒåç§»å€¼
        consistency_mode: ä¸€è‡´æ€§æ¨¡å¼é…ç½®
        """
        self.calibrated_physical_limits = calibrated_physical_limits
        self.center_offsets = center_offsets
        self.consistency_mode = consistency_mode
        self._calculate_corrected_scaling_factors()
        
    def _calculate_corrected_scaling_factors(self):
        """è®¡ç®—ä¿®æ­£çš„ç¼©æ”¾å› å­ï¼šåŸºäºæ ¡å‡†åçš„èŒƒå›´"""
        for stick_type in ['left', 'right']:
            calibrated_limits = self.calibrated_physical_limits[stick_type]
            mode = self.consistency_mode[stick_type]
            
            if mode == 'global_min':
                # ä½¿ç”¨æ ¡å‡†åçš„èŒƒå›´è®¡ç®—å››ä¸ªæ–¹å‘çš„æœ€å°å€¼
                # æ ¡å‡†åçš„èŒƒå›´å·²ç»æ˜¯ç›¸å¯¹äºä¸­å¿ƒç‚¹çš„å®é™…ç§»åŠ¨è·ç¦»
                min_positive_x = abs(calibrated_limits['max_x'])  # å³æ–¹å‘å®é™…èŒƒå›´
                min_negative_x = abs(calibrated_limits['min_x'])  # å·¦æ–¹å‘å®é™…èŒƒå›´
                min_positive_y = abs(calibrated_limits['max_y'])  # ä¸Šæ–¹å‘å®é™…èŒƒå›´
                min_negative_y = abs(calibrated_limits['min_y'])  # ä¸‹æ–¹å‘å®é™…èŒƒå›´
                
                # å–å››ä¸ªæ–¹å‘çš„æœ€å°å€¼ä½œä¸ºç»Ÿä¸€ç¼©æ”¾åŸºå‡†
                global_min_range = min(min_positive_x, min_negative_x, 
                                     min_positive_y, min_negative_y)
                
                # é¿å…é™¤é›¶é”™è¯¯
                if global_min_range < 0.01:
                    global_min_range = 0.8  # é»˜è®¤å®‰å…¨å€¼
                
                # å­˜å‚¨ç¼©æ”¾å› å­
                calibrated_limits['global_scale'] = 1.0 / global_min_range
                calibrated_limits['consistency_mode'] = 'global_min'
                
                # è®¡ç®—å¤–éƒ¨æ­»åŒºç™¾åˆ†æ¯”ï¼ˆåŸºäºæ ¡å‡†åçš„èŒƒå›´ï¼‰
                self._calculate_corrected_external_deadzone(stick_type, global_min_range)
                
                print(f"ğŸ¯ {stick_type}æ‘‡æ†ä¿®æ­£ä¸€è‡´æ€§æ¨¡å¼:")
                print(f"  æ ¡å‡†åèŒƒå›´: X[{calibrated_limits['min_x']:+.3f}â†”{calibrated_limits['max_x']:+.3f}] Y[{calibrated_limits['min_y']:+.3f}â†”{calibrated_limits['max_y']:+.3f}]")
                print(f"  ç»Ÿä¸€ç¼©æ”¾å› å­: {1.0/global_min_range:.3f}x (åŸºå‡†: {global_min_range:.3f})")
                
            else:
                # ä¼ ç»Ÿæ¨¡å¼ï¼šæ¯ä¸ªæ–¹å‘ç‹¬ç«‹ç¼©æ”¾ï¼ˆåŸºäºæ ¡å‡†åçš„èŒƒå›´ï¼‰
                calibrated_limits['x_positive_scale'] = 1.0 / calibrated_limits['max_x'] if abs(calibrated_limits['max_x']) > 0.01 else 1.0
                calibrated_limits['x_negative_scale'] = 1.0 / abs(calibrated_limits['min_x']) if abs(calibrated_limits['min_x']) > 0.01 else 1.0
                calibrated_limits['y_positive_scale'] = 1.0 / calibrated_limits['max_y'] if abs(calibrated_limits['max_y']) > 0.01 else 1.0
                calibrated_limits['y_negative_scale'] = 1.0 / abs(calibrated_limits['min_y']) if abs(calibrated_limits['min_y']) > 0.01 else 1.0
                calibrated_limits['consistency_mode'] = 'independent'
                
                print(f"âš™ï¸  {stick_type}æ‘‡æ†ä¼ ç»Ÿæ¨¡å¼: åŸºäºæ ¡å‡†åèŒƒå›´çš„ç‹¬ç«‹æ–¹å‘ç¼©æ”¾")
    
    def _calculate_corrected_external_deadzone(self, stick_type, global_min_range):
        """è®¡ç®—ä¿®æ­£çš„å¤–éƒ¨æ­»åŒºï¼šåŸºäºæ ¡å‡†åçš„èŒƒå›´"""
        calibrated_limits = self.calibrated_physical_limits[stick_type]
        
        deadzones = {
            'up': max(0, (calibrated_limits['max_y'] - global_min_range) / calibrated_limits['max_y'] * 100) if calibrated_limits['max_y'] > global_min_range else 0,
            'down': max(0, (abs(calibrated_limits['min_y']) - global_min_range) / abs(calibrated_limits['min_y']) * 100) if abs(calibrated_limits['min_y']) > global_min_range else 0,
            'left': max(0, (abs(calibrated_limits['min_x']) - global_min_range) / abs(calibrated_limits['min_x']) * 100) if abs(calibrated_limits['min_x']) > global_min_range else 0,
            'right': max(0, (calibrated_limits['max_x'] - global_min_range) / calibrated_limits['max_x'] * 100) if calibrated_limits['max_x'] > global_min_range else 0
        }
        
        calibrated_limits['external_deadzone'] = deadzones
        
        # æ‰“å°å¤–éƒ¨æ­»åŒºä¿¡æ¯
        deadzone_info = []
        for direction, percentage in deadzones.items():
            if percentage > 0:
                deadzone_info.append(f"{direction}{percentage:.1f}%")
        
        if deadzone_info:
            print(f"  å¤–éƒ¨æ­»åŒº: {', '.join(deadzone_info)}")
        else:
            print("  å¤–éƒ¨æ­»åŒº: æ— ")
        
        # æ˜¾ç¤ºå¯¹ç§°æ€§ä¿¡æ¯
        x_symmetry = abs(abs(calibrated_limits['min_x']) - abs(calibrated_limits['max_x'])) / max(abs(calibrated_limits['min_x']), abs(calibrated_limits['max_x'])) * 100
        y_symmetry = abs(abs(calibrated_limits['min_y']) - abs(calibrated_limits['max_y'])) / max(abs(calibrated_limits['min_y']), abs(calibrated_limits['max_y'])) * 100
        print(f"  å¯¹ç§°æ€§: Xè½´{x_symmetry:.1f}% Yè½´{y_symmetry:.1f}%")

    def apply_center_offset_correction(self, raw_value, stick_type, axis_type):
        """åº”ç”¨ä¸­å¿ƒåç§»æ ¡æ­£"""
        offset = self.center_offsets[stick_type][axis_type]
        return raw_value - offset
        
    def normalize_joystick_value(self, raw_value, axis_type, stick_type):
        """ä¿®æ­£çš„å½’ä¸€åŒ–ï¼šåŸºäºæ ¡å‡†åçš„èŒƒå›´è¿›è¡Œè®¡ç®—"""
        # é¦–å…ˆåº”ç”¨ä¸­å¿ƒåç§»æ ¡æ­£
        corrected_value = self.apply_center_offset_correction(
            raw_value, stick_type, 'x' if axis_type == 'x' else 'y')
        
        calibrated_limits = self.calibrated_physical_limits[stick_type]
        mode = calibrated_limits.get('consistency_mode', 'global_min')
        
        if mode == 'global_min':
            # ä¸€è‡´æ€§æ¨¡å¼ï¼šä½¿ç”¨åŸºäºæ ¡å‡†åèŒƒå›´çš„ç»Ÿä¸€ç¼©æ”¾å› å­
            scale_factor = calibrated_limits['global_scale']
            normalized = corrected_value * scale_factor
        else:
            # ä¼ ç»Ÿæ¨¡å¼ï¼šåŸºäºæ ¡å‡†åèŒƒå›´çš„ç‹¬ç«‹ç¼©æ”¾
            if axis_type == 'x':
                if corrected_value < 0:
                    scale_factor = calibrated_limits['x_negative_scale']
                else:
                    scale_factor = calibrated_limits['x_positive_scale']
            else:  # yè½´
                if corrected_value < 0:
                    scale_factor = calibrated_limits['y_negative_scale']
                else:
                    scale_factor = calibrated_limits['y_positive_scale']
            
            normalized = corrected_value * scale_factor
        
        # é™åˆ¶åœ¨[-1, 1]èŒƒå›´å†…ï¼Œè¶…å‡ºéƒ¨åˆ†ä½œä¸ºå¤–éƒ¨æ­»åŒº
        return max(-1.0, min(1.0, normalized))
    
    def get_consistency_info(self, stick_type):
        """è·å–ä¸€è‡´æ€§ä¿¡æ¯"""
        calibrated_limits = self.calibrated_physical_limits[stick_type]
        mode = calibrated_limits.get('consistency_mode', 'global_min')
        
        info = {
            'mode': mode,
            'calibrated_range': {
                'x': [calibrated_limits['min_x'], calibrated_limits['max_x']],
                'y': [calibrated_limits['min_y'], calibrated_limits['max_y']]
            }
        }
        
        if mode == 'global_min':
            info['global_scale'] = calibrated_limits.get('global_scale', 1.0)
            info['external_deadzone'] = calibrated_limits.get('external_deadzone', {})
        
        return info

# ==================== æ­»åŒºå¤„ç†ç±» ====================
class AdvancedDeadzone:
    def __init__(self, deadzone_config):
        self.deadzone_config = deadzone_config
    
    def apply_square_deadzone(self, x, y, stick_type):
        """æ–¹å½¢æ­»åŒºå¤„ç† - ç‹¬ç«‹æ§åˆ¶"""
        config = self.deadzone_config[stick_type]
        deadzone = config['deadzone']
        outer_threshold = config['outer_threshold']
        response_curve = config['response_curve']
        
        # è®¡ç®—æœ€å¤§ç»å¯¹å€¼ï¼ˆæ–¹å½¢åŒºåŸŸçš„å…³é”®ï¼‰
        max_abs = max(abs(x), abs(y))
        
        # å¦‚æœæœ€å¤§ç»å¯¹å€¼å°äºæ­»åŒºï¼Œè¿”å›0ï¼ˆåœ¨æ­»åŒºå†…ï¼‰
        if max_abs < deadzone:
            return 0.0, 0.0

        # ç¬¬ä¸€æ­¥ï¼šåº”ç”¨æ–¹å½¢å½¢çŠ¶ï¼ˆå…ˆä¿æŒå®Œæ•´æ–¹å½¢ï¼‰
        if max_abs > 0:
            # è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ - ä¿æŒæ–¹å½¢å½¢çŠ¶
            if abs(x) > 0.0001 or abs(y) > 0.0001:
                if abs(x) > abs(y):
                    scale = 1.0 / abs(x)
                    new_x = math.copysign(1.0, x)
                    new_y = y * scale
                else:
                    scale = 1.0 / abs(y)
                    new_x = x * scale
                    new_y = math.copysign(1.0, y)
                
                new_x = max(-1.0, min(1.0, new_x))
                new_y = max(-1.0, min(1.0, new_y))
                
                # ç¬¬äºŒæ­¥ï¼šåº”ç”¨å“åº”æ›²çº¿å’ŒèŒƒå›´é™åˆ¶
                if response_curve != 1.0:
                    normalized = (max_abs - deadzone) / (1.0 - deadzone)
                    scaled_magnitude = normalized ** response_curve
                    final_scale = scaled_magnitude
                else:
                    final_scale = (max_abs - deadzone) / (1.0 - deadzone)
                
                final_scale = min(final_scale, outer_threshold)
                
                new_x *= final_scale
                new_y *= final_scale
                
                return new_x, new_y
        
        return x, y

    def apply_circular_deadzone(self, x, y, stick_type):
        """åœ†å½¢æ­»åŒºå¤„ç† - ç‹¬ç«‹æ§åˆ¶"""
        config = self.deadzone_config[stick_type]
        deadzone = config['deadzone']
        outer_threshold = config['outer_threshold']
        response_curve = config['response_curve']
        
        magnitude = (x**2 + y**2) ** 0.5

        if magnitude < deadzone:
            return 0.0, 0.0

        # åº”ç”¨å“åº”æ›²çº¿
        if response_curve != 1.0:
            normalized = (magnitude - deadzone) / (1.0 - deadzone)
            scaled_magnitude = normalized ** response_curve
            magnitude = scaled_magnitude * (1.0 - deadzone) + deadzone

        # é™åˆ¶æœ€å¤§è¾“å‡º
        magnitude = min(magnitude, outer_threshold)

        # ä¿æŒæ–¹å‘ï¼Œåº”ç”¨ç¼©æ”¾åçš„å¹…åº¦
        if magnitude > 0:
            current_magnitude = (x**2 + y**2) ** 0.5
            if current_magnitude > 0.0001:
                scale = magnitude / current_magnitude
                return x * scale, y * scale
            else:
                return x, y

# ==================== æ–¹å½¢æ˜ å°„å¤„ç†å‡½æ•° ====================
def apply_square_mapping(x, y, strength):
    """
    å°†åœ†å½¢æ‘‡æ†è¾“å‡ºè½¬æ¢ä¸ºæ–¹å½¢è¾“å‡ºï¼Œæ”¯æŒå¼ºåº¦è°ƒèŠ‚
    å¼ºåº¦ä¸º0.0æ—¶ï¼šçº¯åœ†å½¢è¾“å‡º
    å¼ºåº¦ä¸º1.0æ—¶ï¼šçº¯æ–¹å½¢è¾“å‡º
    ä¸­é—´å€¼ï¼šåœ†å½¢å’Œæ–¹å½¢çš„æ··åˆ
    """
    if x == 0 and y == 0:
        return 0.0, 0.0
    
    # å¦‚æœå¼ºåº¦ä¸º0ï¼Œç›´æ¥è¿”å›åŸå§‹å€¼ï¼ˆçº¯åœ†å½¢ï¼‰
    if strength == 0.0:
        return x, y
    
    # è®¡ç®—å½“å‰ç‚¹çš„è§’åº¦å’Œå¹…åº¦
    angle = math.atan2(y, x)
    magnitude = math.sqrt(x*x + y*y)
    
    # è®¡ç®—æ–¹å½¢æ˜ å°„åçš„æœ€å¤§å¯èƒ½å¹…åº¦
    abs_cos = abs(math.cos(angle))
    abs_sin = abs(math.sin(angle))
    
    if abs_cos > abs_sin:
        scale = 1.0 / abs_cos
    else:
        scale = 1.0 / abs_sin
    
    # è®¡ç®—çº¯æ–¹å½¢æ˜ å°„åçš„åæ ‡
    square_x = x * scale
    square_y = y * scale
    
    # ç¡®ä¿æ–¹å½¢æ˜ å°„åçš„å€¼åœ¨[-1, 1]èŒƒå›´å†…
    square_x = max(-1.0, min(1.0, square_x))
    square_y = max(-1.0, min(1.0, square_y))
    
    # å¦‚æœå¼ºåº¦ä¸º1ï¼Œç›´æ¥è¿”å›çº¯æ–¹å½¢æ˜ å°„ç»“æœ
    if strength == 1.0:
        return square_x, square_y
    
    # å¼ºåº¦åœ¨0å’Œ1ä¹‹é—´æ—¶ï¼Œè¿›è¡Œçº¿æ€§æ’å€¼
    circular_weight = 1.0 - strength
    square_weight = strength
    
    # çº¿æ€§æ’å€¼
    result_x = x * circular_weight + square_x * square_weight
    result_y = y * circular_weight + square_y * square_weight
    
    # ç¡®ä¿ç»“æœåœ¨[-1, 1]èŒƒå›´å†…
    result_x = max(-1.0, min(1.0, result_x))
    result_y = max(-1.0, min(1.0, result_y))
    
    return result_x, result_y

# ==================== è¾“å‡ºå¢å¹…å¤„ç†å‡½æ•° ====================
def apply_output_amplifier(x, y, stick_type):
    """åº”ç”¨æ‘‡æ†è¾“å‡ºå¢å¹…"""
    amplifier = OUTPUT_AMPLIFIER[stick_type]
    
    if amplifier != 1.0:
        new_x = x * amplifier
        new_y = y * amplifier
        
        new_x = max(-1.0, min(1.0, new_x))
        new_y = max(-1.0, min(1.0, new_y))
        
        return new_x, new_y
    
    return x, y

# ==================== é…ç½®ä¿¡æ¯æ‰“å°å‡½æ•° ====================
def print_configuration_info(joystick_optimizer):
    """æ‰“å°è¯¦ç»†çš„é…ç½®ä¿¡æ¯"""
    print("\n" + "="*80)
    print("ğŸ® ä¿®æ­£ç‰ˆä¸€è‡´æ€§ä¼˜å…ˆæ‘‡æ†é…ç½®ä¿¡æ¯".center(80))
    print("="*80)
    
    for stick in ['left', 'right']:
        stick_name = "å·¦æ‘‡æ†" if stick == 'left' else "å³æ‘‡æ†"
        info = joystick_optimizer.get_consistency_info(stick)
        
        print(f"\n{stick_name} - æ¨¡å¼: {'ä¸€è‡´æ€§ä¼˜å…ˆ(global_min)' if info['mode'] == 'global_min' else 'ä¼ ç»Ÿç‹¬ç«‹(independent)'}")
        
        # æ˜¾ç¤ºæ ¡å‡†åçš„èŒƒå›´
        calibrated_range = info['calibrated_range']
        print(f"  æ ¡å‡†åèŒƒå›´: X[{calibrated_range['x'][0]:+.3f} â†” {calibrated_range['x'][1]:+.3f}] Y[{calibrated_range['y'][0]:+.3f} â†” {calibrated_range['y'][1]:+.3f}]")
        
        if info['mode'] == 'global_min':
            # æ˜¾ç¤ºä¸€è‡´æ€§æ¨¡å¼è¯¦ç»†ä¿¡æ¯
            scale = info.get('global_scale', 1.0)
            deadzones = info.get('external_deadzone', {})
            
            print(f"  ç»Ÿä¸€ç¼©æ”¾: {scale:.3f}x")
            print(f"  å¤–éƒ¨æ­»åŒº: ä¸Š{deadzones.get('up', 0):.1f}% ä¸‹{deadzones.get('down', 0):.1f}% "
                  f"å·¦{deadzones.get('left', 0):.1f}% å³{deadzones.get('right', 0):.1f}%")
            
            # æ˜¾ç¤ºå¯¹ç§°æ€§ä¼˜åŠ¿
            x_range = calibrated_range['x']
            y_range = calibrated_range['y']
            x_symmetry = abs(abs(x_range[0]) - abs(x_range[1])) / max(abs(x_range[0]), abs(x_range[1])) * 100
            y_symmetry = abs(abs(y_range[0]) - abs(y_range[1])) / max(abs(y_range[0]), abs(y_range[1])) * 100
            
            print(f"  å¯¹ç§°æ€§: Xè½´{x_symmetry:.1f}% Yè½´{y_symmetry:.1f}%")
            print("  âœ… ä¼˜åŠ¿: ç‰©ç†è¡Œç¨‹ä¸€è‡´æ€§ âœ“ å®Œç¾å¯¹ç§°æ€§ âœ“ è‚Œè‚‰è®°å¿†å‹å¥½ âœ“")
        else:
            print("  âš ï¸ æ³¨æ„: ä¼ ç»Ÿæ¨¡å¼å¯èƒ½å¯¼è‡´æ–¹å‘çµæ•åº¦ä¸ä¸€è‡´")
    
    print("="*80)

# ==================== ä¸»ç¨‹åº ====================
# ä½¿ç”¨ä¿®æ­£çš„æ ¡å‡†å‡½æ•°è¯†åˆ«æ‘‡æ†èŒƒå›´å’Œä¸­å¿ƒåç§»
JOYSTICK_PHYSICAL_LIMITS, CENTER_OFFSETS = calibrate_joystick_range_and_center()

# åˆå§‹åŒ–ä¿®æ­£çš„ä¸€è‡´æ€§ä¼˜å…ˆä¼˜åŒ–å™¨
joystick_optimizer = CorrectedConsistentJoystickOptimizer(
    JOYSTICK_PHYSICAL_LIMITS, 
    CENTER_OFFSETS, 
    CONSISTENCY_MODE
)

# åˆå§‹åŒ–å…¶ä»–å¤„ç†å™¨
deadzone_processor = AdvancedDeadzone(DEADZONE_CONFIG)

# æ‘‡æ†æ•°æ®ç¼“å­˜
stick_data_cache = {
    'left': {'x': 0.0, 'y': 0.0},
    'right': {'x': 0.0, 'y': 0.0}
}

# é«˜ç²¾åº¦å®šæ—¶å™¨
last_update_time = time.perf_counter()
update_interval = 1.0 / UPDATE_RATE

# ==================== å¤„ç†å‡½æ•° ====================
def process_joysticks_optimized(joystick):
    """ä¼˜åŒ–çš„æ‘‡æ†å¤„ç†ï¼ŒåŒ…å«ä¿®æ­£çš„ä¸€è‡´æ€§ä¼˜å…ˆæ˜ å°„"""
    global stick_data_cache

    if joystick.get_numaxes() < 4:
        return

    try:
        # è¯»å–åŸå§‹æ‘‡æ†æ•°æ®
        left_x = joystick.get_axis(0)
        left_y = joystick.get_axis(1)
        right_x = joystick.get_axis(2)
        right_y = joystick.get_axis(3)

        # åº”ç”¨ä¿®æ­£çš„ä¸€è‡´æ€§ä¼˜å…ˆå½’ä¸€åŒ–
        left_x = joystick_optimizer.normalize_joystick_value(left_x, 'x', 'left')
        left_y = joystick_optimizer.normalize_joystick_value(left_y, 'y', 'left')
        right_x = joystick_optimizer.normalize_joystick_value(right_x, 'x', 'right')
        right_y = joystick_optimizer.normalize_joystick_value(right_y, 'y', 'right')

        # åº”ç”¨æ–¹å½¢æ˜ å°„
        left_strength = SQUARE_MAPPING_STRENGTH['left_stick']
        right_strength = SQUARE_MAPPING_STRENGTH['right_stick']
        
        if left_strength > 0.0:
            left_x, left_y = apply_square_mapping(left_x, left_y, left_strength)
        if right_strength > 0.0:
            right_x, right_y = apply_square_mapping(right_x, right_y, right_strength)

        # åº”ç”¨æ­»åŒºç®—æ³•
        if SQUARE_DEADZONE_SWITCH['left_stick']:
            left_x, left_y = deadzone_processor.apply_square_deadzone(left_x, left_y, 'left')
        else:
            left_x, left_y = deadzone_processor.apply_circular_deadzone(left_x, left_y, 'left')
            
        if SQUARE_DEADZONE_SWITCH['right_stick']:
            right_x, right_y = deadzone_processor.apply_square_deadzone(right_x, right_y, 'right')
        else:
            right_x, right_y = deadzone_processor.apply_circular_deadzone(right_x, right_y, 'right')

        # åº”ç”¨è¾“å‡ºå¢å¹…
        left_x, left_y = apply_output_amplifier(left_x, left_y, 'left_stick')
        right_x, right_y = apply_output_amplifier(right_x, right_y, 'right_stick')

        # æ›´æ–°ç¼“å­˜
        stick_data_cache['left']['x'] = left_x
        stick_data_cache['left']['y'] = left_y
        stick_data_cache['right']['x'] = right_x
        stick_data_cache['right']['y'] = right_y

    except Exception as e:
        print(f"æ‘‡æ†è¯»å–é”™è¯¯: {e}")

def process_trigger_buttons():
    """å¤„ç†æ‰³æœºæŒ‰é’®ï¼ˆæŒ‰é’®5å’Œ13ï¼‰"""
    global trigger_states

    try:
        # å³æ‰³æœºæŒ‰é’® (ZR - æŒ‰é’®5)
        zr_pressed = bool(joystick.get_button(5))
        trigger_states['right'] = 1.0 if zr_pressed else 0.0

        # å·¦æ‰³æœºæŒ‰é’® (ZL - æŒ‰é’®13)
        zl_pressed = bool(joystick.get_button(13))
        trigger_states['left'] = 1.0 if zl_pressed else 0.0

    except Exception as e:
        print(f"æ‰³æœºæŒ‰é’®è¯»å–é”™è¯¯: {e}")

def update_virtual_gamepad():
    """é«˜é€Ÿæ›´æ–°è™šæ‹Ÿæ‰‹æŸ„"""
    global last_update_time

    while True:
        current_time = time.perf_counter()
        elapsed = current_time - last_update_time

        if elapsed >= update_interval:
            try:
                # è®¾ç½®æ‘‡æ†
                left = stick_data_cache['left']
                right = stick_data_cache['right']

                virtual_gamepad.left_joystick_float(left['x'], left['y'])
                virtual_gamepad.right_joystick_float(right['x'], right['y'])

                # è®¾ç½®æ‰³æœº
                virtual_gamepad.left_trigger_float(trigger_states['left'])
                virtual_gamepad.right_trigger_float(trigger_states['right'])

                virtual_gamepad.update()
                last_update_time = current_time

            except Exception as e:
                print(f"è™šæ‹Ÿæ‰‹æŸ„æ›´æ–°é”™è¯¯: {e}")

        time.sleep(0.001)

# å¯åŠ¨é«˜é€Ÿæ›´æ–°çº¿ç¨‹
update_thread = threading.Thread(target=update_virtual_gamepad, daemon=True)
update_thread.start()

# æ£€æŸ¥pyautoguiå¯ç”¨æ€§
try:
    import pyautogui
    USE_PYAUTOGUI = True
    print("ä½¿ç”¨pyautoguiè¿›è¡Œé”®ç›˜æ¨¡æ‹Ÿ")
except ImportError:
    USE_PYAUTOGUI = False
    print("pyautoguiæœªå®‰è£…ï¼Œä½¿ç”¨pygameäº‹ä»¶æ¨¡æ‹Ÿ")
    print("å®‰è£…pyautogui: pip install pyautogui")

# æ‰“å°é…ç½®ä¿¡æ¯
print_configuration_info(joystick_optimizer)

try:
    print(f"\nğŸ® ä¿®æ­£ç‰ˆä¸€è‡´æ€§ä¼˜å…ˆæ‘‡æ†æ˜ å°„å·²å¯åŠ¨ï¼ˆ{UPDATE_RATE}Hz æ›´æ–°ç‡ï¼‰")
    print("âœ… ç‰©ç†è¡Œç¨‹ä¸€è‡´æ€§ä¼˜åŒ–å·²å¯ç”¨")
    
    # æ˜¾ç¤ºè¯¦ç»†é…ç½®
    for stick in ['left', 'right']:
        mode = CONSISTENCY_MODE[stick]
        stick_name = "å·¦æ‘‡æ†" if stick == 'left' else "å³æ‘‡æ†"
        mode_desc = "ä¸€è‡´æ€§ä¼˜å…ˆ" if mode == 'global_min' else "ä¼ ç»Ÿç‹¬ç«‹"
        print(f"{stick_name}: {mode_desc}æ¨¡å¼")
    
    # æ˜¾ç¤ºæ­»åŒºé…ç½®
    left_config = DEADZONE_CONFIG['left']
    right_config = DEADZONE_CONFIG['right']
    print(f"\nå·¦æ‘‡æ†æ­»åŒº: {left_config['deadzone']:.3f}, å¤–ç¯: {left_config['outer_threshold']:.2f}")
    print(f"å³æ‘‡æ†æ­»åŒº: {right_config['deadzone']:.3f}, å¤–ç¯: {right_config['outer_threshold']:.2f}")
    
    # æ˜¾ç¤ºæ–¹å½¢æ­»åŒºçŠ¶æ€
    left_status = "å¼€å¯" if SQUARE_DEADZONE_SWITCH['left_stick'] else "å…³é—­"
    right_status = "å¼€å¯" if SQUARE_DEADZONE_SWITCH['right_stick'] else "å…³é—­"
    print(f"å·¦æ‘‡æ†æ–¹å½¢æ­»åŒº: {left_status}")
    print(f"å³æ‘‡æ†æ–¹å½¢æ­»åŒº: {right_status}")
    
    # æ˜¾ç¤ºæ–¹å½¢æ˜ å°„å¼ºåº¦
    left_strength = SQUARE_MAPPING_STRENGTH['left_stick']
    right_strength = SQUARE_MAPPING_STRENGTH['right_stick']
    print(f"å·¦æ‘‡æ†æ–¹å½¢æ˜ å°„: {left_strength:.1f}")
    print(f"å³æ‘‡æ†æ–¹å½¢æ˜ å°„: {right_strength:.1f}")
    
    # æ˜¾ç¤ºè¾“å‡ºå¢å¹…çŠ¶æ€
    print(f"å·¦æ‘‡æ†è¾“å‡ºå¢å¹…: {OUTPUT_AMPLIFIER['left_stick']:.1f}x")
    print(f"å³æ‘‡æ†è¾“å‡ºå¢å¹…: {OUTPUT_AMPLIFIER['right_stick']:.1f}x")
    
    print("\nğŸ’¡ ä¼˜åŠ¿: æ¶ˆé™¤çœ©æ™•æ„Ÿ âœ“ ä¿æŠ¤è‚Œè‚‰è®°å¿† âœ“ è½¬å‘åŠ é€Ÿåº¦ä¸€è‡´ âœ“")
    print("æ‰³æœºæŒ‰é’®: ZL=æŒ‰é’®13, ZR=æŒ‰é’®5")
    
    # æ‰“å°ç‰¹æ®ŠæŒ‰é’®é…ç½®
    for btn_id, config in SPECIAL_BUTTONS.items():
        print(f"æŒ‰é’®{btn_id}: {config['description']}")

    while True:
        pygame.event.pump()

        # å¤„ç†æ‰€æœ‰æŒ‰é’®
        num_buttons = min(joystick.get_numbuttons(), 25)
        for i in range(num_buttons):
            try:
                current_state = bool(joystick.get_button(i))
            except:
                current_state = False

            if current_state != button_states[i]:
                button_name = PHYSICAL_TO_NAME.get(i, f"Btn{i}")

                # ç‰¹æ®ŠæŒ‰é’®å¤„ç†
                if i in SPECIAL_BUTTONS:
                    config = SPECIAL_BUTTONS[i]
                    keys = config['keys']  # è·å–é”®åˆ—è¡¨
                    
                    if current_state:
                        if USE_PYAUTOGUI:
                            # æŒ‰ä¸‹æ‰€æœ‰é”®
                            for key in keys:
                                pyautogui.keyDown(key)
                        else:
                            # pygameå¤„ç†
                            for key in keys:
                                try:
                                    key_code = getattr(pygame, f"K_{key.upper()}")
                                    key_event = pygame.event.Event(pygame.KEYDOWN, key=key_code)
                                    pygame.event.post(key_event)
                                except AttributeError:
                                    print(f"æ— æ³•è¯†åˆ«çš„é”®: {key}")
                        
                        key_names = '+'.join(keys).upper()
                        print(f"æŒ‰ä¸‹: {button_name} -> é”®ç›˜{key_names}é”®æŒ‰ä¸‹")
                    else:
                        if USE_PYAUTOGUI:
                            # é‡Šæ”¾æ‰€æœ‰é”®ï¼ˆåå‘é¡ºåºï¼‰
                            for key in reversed(keys):
                                pyautogui.keyUp(key)
                        else:
                            # pygameå¤„ç†
                            for key in reversed(keys):
                                try:
                                    key_code = getattr(pygame, f"K_{key.upper()}")
                                    key_event = pygame.event.Event(pygame.KEYUP, key=key_code)
                                    pygame.event.post(key_event)
                                except AttributeError:
                                    print(f"æ— æ³•è¯†åˆ«çš„é”®: {key}")
                        
                        key_names = '+'.join(keys).upper()
                        print(f"é‡Šæ”¾: {button_name} -> é”®ç›˜{key_names}é”®é‡Šæ”¾")
                    
                    button_states[i] = current_state
                    continue

                # æ™®é€šæŒ‰é’®å¤„ç†
                if i in PHYSICAL_TO_XBOX:
                    target = PHYSICAL_TO_XBOX[i]

                    if isinstance(target, XUSB_BUTTON):
                        if current_state:
                            virtual_gamepad.press_button(target)
                            print(f"æŒ‰ä¸‹: {button_name}")
                        else:
                            virtual_gamepad.release_button(target)
                            print(f"é‡Šæ”¾: {button_name}")

                    elif isinstance(target, str) and target in ['left_trigger', 'right_trigger']:
                        if current_state:
                            print(f"æŒ‰ä¸‹æ‰³æœº: {button_name}")
                        else:
                            print(f"é‡Šæ”¾æ‰³æœº: {button_name}")

                button_states[i] = current_state

        # å¤„ç†pygameäº‹ä»¶é˜Ÿåˆ—
        if not USE_PYAUTOGUI:
            for event in pygame.event.get():
                if event.type in (pygame.KEYDOWN, pygame.KEYUP):
                    pass

        # å¤„ç†æ‰³æœºæŒ‰é’®çŠ¶æ€
        process_trigger_buttons()

        # å¤„ç†æ‘‡æ†
        process_joysticks_optimized(joystick)

        time.sleep(0.001)

except KeyboardInterrupt:
    virtual_gamepad.reset()
    virtual_gamepad.update()
    pygame.quit()
    print("\nğŸ® ç¨‹åºå·²é€€å‡ºï¼Œæ„Ÿè°¢ä½¿ç”¨ä¿®æ­£ç‰ˆä¸€è‡´æ€§ä¼˜å…ˆæ‘‡æ†æ˜ å°„ï¼")