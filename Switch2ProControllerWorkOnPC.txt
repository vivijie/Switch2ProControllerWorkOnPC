import pygame
import time
import threading
import math
from collections import deque
from vgamepad import VX360Gamepad, XUSB_BUTTON

# ==================== 配置区域 ====================
# 默认摇杆物理限制校准（防呆设计，使用0.8作为安全值）
DEFAULT_PHYSICAL_LIMITS = {
    'left': {'min_x': -0.8, 'max_x': 0.8, 'min_y': -0.8, 'max_y': 0.8},
    'right': {'min_x': -0.8, 'max_x': 0.8, 'min_y': -0.8, 'max_y': 0.8}
}

# 独立死区配置 - 左右摇杆分别设置
DEADZONE_CONFIG = {
    'left': {
        'deadzone': 0.03,
        'outer_threshold': 0.9,
        'response_curve': 1.0
    },
    'right': {
        'deadzone': 0.03, 
        'outer_threshold': 1.0,
        'response_curve': 1.0
    }
}


# 摇杆输出增幅配置 (1.0=无增幅, 1.1=10%增幅, 0.9=10%衰减)
OUTPUT_AMPLIFIER = {
    'left_stick': 1.1,   # 左摇杆输出增幅
    'right_stick': 1.0    # 右摇杆输出增幅
}


# 方形死区开关配置 (0=关闭, 1=开启)
SQUARE_DEADZONE_SWITCH = {
    'left_stick': 1,   # 左摇杆方形死区开关
    'right_stick': 1   # 右摇杆方形死区开关
}


# 更新率配置
UPDATE_RATE = 1000  # Hz

# 按钮映射
PHYSICAL_TO_NAME = {
    0: "A", 1: "B", 2: "X", 3: "Y",
    4: "R", 5: "ZR", 6: "Plus", 7: "RStick",
    8: "Down", 9: "Right", 10: "Left", 11: "Up",
    12: "L", 13: "ZL", 14: "Min", 15: "LStick",
    16: "Home", 17: "Capture",
    18: "BR", 19: "BL"
}

NAME_TO_XBOX = {
    "BR": XUSB_BUTTON.XUSB_GAMEPAD_B,
    "BL": XUSB_BUTTON.XUSB_GAMEPAD_A,
    "A": XUSB_BUTTON.XUSB_GAMEPAD_A,
    "B": XUSB_BUTTON.XUSB_GAMEPAD_B,
    "X": XUSB_BUTTON.XUSB_GAMEPAD_X,
    "Y": XUSB_BUTTON.XUSB_GAMEPAD_Y,
    "L": XUSB_BUTTON.XUSB_GAMEPAD_LEFT_SHOULDER,
    "R": XUSB_BUTTON.XUSB_GAMEPAD_RIGHT_SHOULDER,
    "Min": XUSB_BUTTON.XUSB_GAMEPAD_BACK,
    "Plus": XUSB_BUTTON.XUSB_GAMEPAD_START,
    "Home": XUSB_BUTTON.XUSB_GAMEPAD_START,
    "Capture": XUSB_BUTTON.XUSB_GAMEPAD_BACK,
    "LStick": XUSB_BUTTON.XUSB_GAMEPAD_LEFT_THUMB,
    "RStick": XUSB_BUTTON.XUSB_GAMEPAD_RIGHT_THUMB,
    "Up": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_UP,
    "Down": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_DOWN,
    "Left": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_LEFT,
    "Right": XUSB_BUTTON.XUSB_GAMEPAD_DPAD_RIGHT,
    "ZL": "left_trigger",
    "ZR": "right_trigger"
}

# 特殊按键配置
SPECIAL_BUTTONS = {
    17: {'key': 't', 'description': 'Capture按钮映射为键盘T键'}
}

# ==================== 初始化 ====================
pygame.init()
pygame.joystick.init()
virtual_gamepad = VX360Gamepad()

joystick_count = pygame.joystick.get_count()
if joystick_count == 0:
    print("未检测到手柄!")
    exit()

joystick = pygame.joystick.Joystick(0)
joystick.init()

print(f"检测到手柄: {joystick.get_name()}")
print("按钮数量:", joystick.get_numbuttons())
print("按 Ctrl+C 退出")

# 创建物理到XBOX的映射
PHYSICAL_TO_XBOX = {}
for physical_idx, button_name in PHYSICAL_TO_NAME.items():
    if button_name in NAME_TO_XBOX:
        PHYSICAL_TO_XBOX[physical_idx] = NAME_TO_XBOX[button_name]

# 按钮状态数组
button_states = [False] * 25
trigger_states = {'left': 0.0, 'right': 0.0}

# ==================== 摇杆范围自动识别函数 ====================
def calibrate_joystick_range():
    """自动识别摇杆物理范围 - 同时校准左右摇杆"""
    print("\n" + "="*60)
    print("🎮 摇杆范围自动识别".center(60))
    print("="*60)
    print("请同时转动左右摇杆3圈，覆盖所有方向")
    print("确保摇杆移动到各个角落")
    print("10秒后自动完成校准")
    print("="*60)
    
    # 初始化范围数据（从当前值开始，而不是默认值）
    calibration_data = {
        'left': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0},
        'right': {'min_x': 0.0, 'max_x': 0.0, 'min_y': 0.0, 'max_y': 0.0}
    }
    
    # 检查摇杆数量
    if joystick.get_numaxes() < 4:
        print("错误: 摇杆轴数量不足，使用默认范围")
        return DEFAULT_PHYSICAL_LIMITS
    
    # 先读取一次初始值来初始化范围
    try:
        pygame.event.pump()
        calibration_data['left']['min_x'] = calibration_data['left']['max_x'] = joystick.get_axis(0)
        calibration_data['left']['min_y'] = calibration_data['left']['max_y'] = joystick.get_axis(1)
        calibration_data['right']['min_x'] = calibration_data['right']['max_x'] = joystick.get_axis(2)
        calibration_data['right']['min_y'] = calibration_data['right']['max_y'] = joystick.get_axis(3)
    except:
        print("初始化读取失败，使用默认范围")
        return DEFAULT_PHYSICAL_LIMITS
    
    print("\n🔄 正在校准摇杆范围...")
    print("请同时转动左右摇杆3圈")
    
    start_time = time.time()
    calibration_time = 10  # 校准时间增加到10秒
    
    while time.time() - start_time < calibration_time:
        pygame.event.pump()
        
        try:
            # 同时读取左右摇杆原始数据
            left_x = joystick.get_axis(0)
            left_y = joystick.get_axis(1)
            right_x = joystick.get_axis(2)
            right_y = joystick.get_axis(3)
            
            # 更新左摇杆最小值最大值 - 直接更新，不设限制
            calibration_data['left']['min_x'] = min(calibration_data['left']['min_x'], left_x)
            calibration_data['left']['max_x'] = max(calibration_data['left']['max_x'], left_x)
            calibration_data['left']['min_y'] = min(calibration_data['left']['min_y'], left_y)
            calibration_data['left']['max_y'] = max(calibration_data['left']['max_y'], left_y)
            
            # 更新右摇杆最小值最大值 - 直接更新，不设限制
            calibration_data['right']['min_x'] = min(calibration_data['right']['min_x'], right_x)
            calibration_data['right']['max_x'] = max(calibration_data['right']['max_x'], right_x)
            calibration_data['right']['min_y'] = min(calibration_data['right']['min_y'], right_y)
            calibration_data['right']['max_y'] = max(calibration_data['right']['max_y'], right_y)
            
            # 显示当前进度
            remaining_time = calibration_time - (time.time() - start_time)
            print(f"\r校准中... {remaining_time:.1f}秒 左:[X{calibration_data['left']['min_x']:+.3f}↔{calibration_data['left']['max_x']:+.3f} Y{calibration_data['left']['min_y']:+.3f}↔{calibration_data['left']['max_y']:+.3f}] 右:[X{calibration_data['right']['min_x']:+.3f}↔{calibration_data['right']['max_x']:+.3f} Y{calibration_data['right']['min_y']:+.3f}↔{calibration_data['right']['max_y']:+.3f}]", 
                  end="", flush=True)
            
            time.sleep(0.01)
            
        except Exception as e:
            print(f"\n校准错误: {e}")
            # 出错时使用当前已读取的数据，不退回默认值
            break
    
    # 验证校准结果的有效性 - 放宽验证条件
    for stick in ['left', 'right']:
        limits = calibration_data[stick]
        
        # 检查是否读取到了有效数据（只要不是全0就认为有效）
        if (abs(limits['min_x']) < 0.01 and abs(limits['max_x']) < 0.01 and
            abs(limits['min_y']) < 0.01 and abs(limits['max_y']) < 0.01):
            print(f"\n⚠️  {stick}摇杆未检测到有效移动，使用默认范围")
            calibration_data[stick] = DEFAULT_PHYSICAL_LIMITS[stick].copy()
        else:
            # 确保最小值确实小于最大值（处理初始化问题）
            if limits['min_x'] > limits['max_x']:
                limits['min_x'], limits['max_x'] = limits['max_x'], limits['min_x']
            if limits['min_y'] > limits['max_y']:
                limits['min_y'], limits['max_y'] = limits['max_y'], limits['min_y']
    
    print("\n\n✅ 摇杆校准完成!")
    
    # 显示最终校准结果
    print("\n" + "="*60)
    print("🎯 校准结果".center(60))
    print("="*60)
    for stick, limits in calibration_data.items():
        stick_name = "左摇杆" if stick == 'left' else "右摇杆"
        print(f"{stick_name}: X[{limits['min_x']:+.3f} ↔ {limits['max_x']:+.3f}] "
              f"Y[{limits['min_y']:+.3f} ↔ {limits['max_y']:+.3f}]")
    
    print("="*60)
    
    return calibration_data

# ==================== 终端显示函数 ====================
def print_configuration_info(physical_limits):
    """打印漂亮的配置信息"""
    print("\n" + "="*60)
    print("🎮 手柄映射配置信息".center(60))
    print("="*60)
    
    # 死区配置显示 - 左右独立
    print("\n📊 死区配置:")
    for stick in ['left', 'right']:
        stick_name = "左摇杆" if stick == 'left' else "右摇杆"
        config = DEADZONE_CONFIG[stick]
        
        deadzone_bar = "[" + "■" * int(config['deadzone'] * 20) + "○" * (20 - int(config['deadzone'] * 20)) + "]"
        outer_bar = "[" + "■" * int(config['outer_threshold'] * 20) + "○" * (20 - int(config['outer_threshold'] * 20)) + "]"
        
        print(f"   {stick_name}:")
        print(f"     死区: {config['deadzone']:.3f} {deadzone_bar}")
        print(f"     外环: {config['outer_threshold']:.2f} {outer_bar}")
        print(f"     曲线: {config['response_curve']:.1f}")
    
    # 方形死区开关显示
    print("\n🔲 方形死区开关:")
    left_status = "■ 开启" if SQUARE_DEADZONE_SWITCH['left_stick'] else "□ 关闭"
    right_status = "■ 开启" if SQUARE_DEADZONE_SWITCH['right_stick'] else "□ 关闭"
    print(f"   左摇杆: {left_status}")
    print(f"   右摇杆: {right_status}")
    
    # 输出增幅显示
    print("\n📊 输出增幅:")
    left_amp = f"{OUTPUT_AMPLIFIER['left_stick']:.1f}x"
    right_amp = f"{OUTPUT_AMPLIFIER['right_stick']:.1f}x"
    left_amp_bar = "[" + "■" * int((OUTPUT_AMPLIFIER['left_stick'] - 0.5) * 20) + "○" * (20 - int((OUTPUT_AMPLIFIER['left_stick'] - 0.5) * 20)) + "]"
    right_amp_bar = "[" + "■" * int((OUTPUT_AMPLIFIER['right_stick'] - 0.5) * 20) + "○" * (20 - int((OUTPUT_AMPLIFIER['right_stick'] - 0.5) * 20)) + "]"
    print(f"   左摇杆: {left_amp} {left_amp_bar}")
    print(f"   右摇杆: {right_amp} {right_amp_bar}")
    
    # 摇杆范围显示
    print("\n🎯 摇杆物理范围:")
    for stick, limits in physical_limits.items():
        stick_name = "左摇杆" if stick == 'left' else "右摇杆"
        print(f"   {stick_name}: X[{limits['min_x']:+.3f} ↔ {limits['max_x']:+.3f}] "
              f"Y[{limits['min_y']:+.3f} ↔ {limits['max_y']:+.3f}]")
    
    # 摇杆死区示意图 - 合并显示左右摇杆
    print("\n🕹️  摇杆死区示意图:")
    
    # 左摇杆示意图
    left_config = DEADZONE_CONFIG['left']
    right_config = DEADZONE_CONFIG['right']
    
    print("   " + " " * 10 + "左摇杆" + " " * 21 + "右摇杆")
    print("   " + " " * 8 + "╔═════════════╗" + " " * 5 + "╔═════════════╗")
    print("   " + " " * 8 + "║      ↑      ║" + " " * 5 + "║      ↑      ║")
    print("   " + " " * 8 + "║     Y+      ║" + " " * 5 + "║     Y+      ║")
    print("   " + " " * 5 + "← X- ║     ○     ║ X+ →" + " " * 5 + "← X- ║     ○     ║ X+ →")
    print("   " + " " * 8 + "║     Y-      ║" + " " * 5 + "║     Y-      ║")
    print("   " + " " * 8 + "║      ↓      ║" + " " * 5 + "║      ↓      ║")
    print("   " + " " * 8 + "╚═════════════╝" + " " * 5 + "╚═════════════╝")
    
    # 死区范围标注 - 独立显示
    print(f"   中心死区: {left_config['deadzone']:.3f}" + " " * 18 + f"中心死区: {right_config['deadzone']:.3f}")
    print(f"   外围死区: {left_config['outer_threshold']:.2f}" + " " * 18 + f"外围死区: {right_config['outer_threshold']:.2f}")
    
    # 形状标注
    left_shape = "方形" if SQUARE_DEADZONE_SWITCH['left_stick'] else "圆形"
    right_shape = "方形" if SQUARE_DEADZONE_SWITCH['right_stick'] else "圆形"
    print(f"   输出形状: {left_shape}" + " " * 20 + f"输出形状: {right_shape}")
    
    # 增幅标注
    print(f"   输出增幅: {OUTPUT_AMPLIFIER['left_stick']:.1f}x" + " " * 19 + f"输出增幅: {OUTPUT_AMPLIFIER['right_stick']:.1f}x")
    
    # 更新率显示
    print(f"\n⚡ 更新率: {UPDATE_RATE}Hz")
    
    # 特殊按钮显示
    print("\n🔧 特殊功能按钮:")
    for btn_id, config in SPECIAL_BUTTONS.items():
        btn_name = PHYSICAL_TO_NAME.get(btn_id, f"Btn{btn_id}")
        print(f"   {btn_name}({btn_id}) → {config['description']}")
    
    # 按钮映射显示
    print("\n🎯 按钮映射表:")
    print("   ╔═════╦══════╦══════════════╗")
    print("   ║ 编号 ║ 名称 ║   映射到     ║")
    print("   ╠═════╬══════╬══════════════╣")
    
    for i in range(min(20, len(PHYSICAL_TO_NAME))):
        if i in PHYSICAL_TO_NAME:
            btn_name = PHYSICAL_TO_NAME[i]
            xbox_map = "扳机" if btn_name in ["ZL", "ZR"] else "按钮"
            print(f"   ║  {i:2d} ║  {btn_name:3s} ║ {xbox_map:12s} ║")
    
    print("   ╚═════╩══════╩══════════════╝")
    
    print("\n" + "="*60)
    print("🚀 手柄映射已启动，开始享受游戏吧！".center(60))
    print("="*60 + "\n")

# ==================== 摇杆范围优化类 ====================
class JoystickRangeOptimizer:
    def __init__(self, physical_limits):
        self.physical_limits = physical_limits
        
    def normalize_joystick_value(self, value, axis_type, stick_type):
        """将物理摇杆值归一化到[-1, 1]范围 - 使用准确的物理范围"""
        limits = self.physical_limits[stick_type]
        
        if axis_type == 'x':
            # 将x轴从实际物理范围映射到[-1, 1]
            if value < 0:
                # 负方向：从[min_x, 0]映射到[-1, 0]
                if abs(limits['min_x']) > 0.001:  # 避免除零
                    normalized = value / abs(limits['min_x'])
                else:
                    normalized = value  # 如果最小值为0，直接使用原值
            else:
                # 正方向：从[0, max_x]映射到[0, 1]
                if abs(limits['max_x']) > 0.001:  # 避免除零
                    normalized = value / limits['max_x']
                else:
                    normalized = value  # 如果最大值为0，直接使用原值
        else:  # y轴
            # 将y轴从实际物理范围映射到[-1, 1]
            if value < 0:
                # 负方向：从[min_y, 0]映射到[-1, 0]
                if abs(limits['min_y']) > 0.001:  # 避免除零
                    normalized = value / abs(limits['min_y'])
                else:
                    normalized = value  # 如果最小值为0，直接使用原值
            else:
                # 正方向：从[0, max_y]映射到[0, 1]
                if abs(limits['max_y']) > 0.001:  # 避免除零
                    normalized = value / limits['max_y']
                else:
                    normalized = value  # 如果最大值为0，直接使用原值
                
        # 确保值在[-1, 1]范围内
        return max(-1.0, min(1.0, normalized))

# ==================== 死区处理类 ====================
class AdvancedDeadzone:
    def __init__(self, deadzone_config):
        self.deadzone_config = deadzone_config
    
    def apply_square_deadzone(self, x, y, stick_type):
        """方形死区处理 - 独立控制"""
        config = self.deadzone_config[stick_type]
        deadzone = config['deadzone']
        outer_threshold = config['outer_threshold']
        response_curve = config['response_curve']
        
        # 计算最大绝对值（方形区域的关键）
        max_abs = max(abs(x), abs(y))
        
        # 如果最大绝对值小于死区，返回0（在死区内）
        if max_abs < deadzone:
            return 0.0, 0.0

        # 第一步：应用方形形状（先保持完整方形）
        if max_abs > 0:
            # 计算缩放比例 - 保持方形形状
            if abs(x) > 0.0001 or abs(y) > 0.0001:  # 避免除零
                # 找到主导轴（x或y中绝对值较大的）
                if abs(x) > abs(y):
                    # x轴主导，保持x的比例，相应缩放y
                    scale = 1.0 / abs(x)  # 先缩放到完整方形
                    new_x = math.copysign(1.0, x)
                    new_y = y * scale
                else:
                    # y轴主导，保持y的比例，相应缩放x
                    scale = 1.0 / abs(y)  # 先缩放到完整方形
                    new_x = x * scale
                    new_y = math.copysign(1.0, y)
                
                # 确保不会超出[-1, 1]范围
                new_x = max(-1.0, min(1.0, new_x))
                new_y = max(-1.0, min(1.0, new_y))
                
                # 第二步：应用响应曲线和范围限制（后处理范围）
                # 计算原始输入的幅度用于响应曲线
                if response_curve != 1.0:
                    # 使用原始输入的幅度来计算响应曲线
                    normalized = (max_abs - deadzone) / (1.0 - deadzone)
                    scaled_magnitude = normalized ** response_curve
                    final_scale = scaled_magnitude
                else:
                    # 线性响应
                    final_scale = (max_abs - deadzone) / (1.0 - deadzone)
                
                # 应用外环阈值限制
                final_scale = min(final_scale, outer_threshold)
                
                # 应用最终缩放
                new_x *= final_scale
                new_y *= final_scale
                
                return new_x, new_y
        
        return x, y

    def apply_circular_deadzone(self, x, y, stick_type):
        """圆形死区处理 - 独立控制"""
        config = self.deadzone_config[stick_type]
        deadzone = config['deadzone']
        outer_threshold = config['outer_threshold']
        response_curve = config['response_curve']
        
        magnitude = (x**2 + y**2) ** 0.5

        if magnitude < deadzone:
            return 0.0, 0.0

        # 应用响应曲线
        if response_curve != 1.0:
            normalized = (magnitude - deadzone) / (1.0 - deadzone)
            scaled_magnitude = normalized ** response_curve
            magnitude = scaled_magnitude * (1.0 - deadzone) + deadzone

        # 限制最大输出
        magnitude = min(magnitude, outer_threshold)

        # 保持方向，应用缩放后的幅度
        if magnitude > 0:
            scale = magnitude / max(magnitude, 0.0001)  # 避免除零
            return x * scale, y * scale

        return x, y

# ==================== 输出增幅处理函数 ====================
def apply_output_amplifier(x, y, stick_type):
    """应用摇杆输出增幅"""
    amplifier = OUTPUT_AMPLIFIER[stick_type]
    
    if amplifier != 1.0:
        # 计算当前幅度
        current_magnitude = max(abs(x), abs(y))
        
        if current_magnitude > 0:
            # 应用增幅，但限制在有效范围内
            new_x = x * amplifier
            new_y = y * amplifier
            
            # 确保不超过[-1, 1]范围
            new_x = max(-1.0, min(1.0, new_x))
            new_y = max(-1.0, min(1.0, new_y))
            
            return new_x, new_y
    
    return x, y

# ==================== 主程序 ====================
# 自动识别摇杆范围
JOYSTICK_PHYSICAL_LIMITS = calibrate_joystick_range()

# 初始化处理器 - 传入独立配置
deadzone_processor = AdvancedDeadzone(DEADZONE_CONFIG)
joystick_optimizer = JoystickRangeOptimizer(JOYSTICK_PHYSICAL_LIMITS)

# 摇杆数据缓存
stick_data_cache = {
    'left': {'x': 0.0, 'y': 0.0},
    'right': {'x': 0.0, 'y': 0.0}
}

# 高精度定时器
last_update_time = time.perf_counter()
update_interval = 1.0 / UPDATE_RATE

# ==================== 处理函数 ====================
def process_joysticks_optimized(joystick):
    """优化的摇杆处理，包括范围归一化"""
    global stick_data_cache

    if joystick.get_numaxes() < 4:
        return

    try:
        # 读取原始摇杆数据
        left_x = joystick.get_axis(0)
        left_y = joystick.get_axis(1)
        right_x = joystick.get_axis(2)
        right_y = joystick.get_axis(3)

        # 应用范围归一化 - 使用准确的物理范围映射到[-1, 1]
        left_x = joystick_optimizer.normalize_joystick_value(left_x, 'x', 'left')
        left_y = joystick_optimizer.normalize_joystick_value(left_y, 'y', 'left')
        right_x = joystick_optimizer.normalize_joystick_value(right_x, 'x', 'right')
        right_y = joystick_optimizer.normalize_joystick_value(right_y, 'y', 'right')

        # 应用死区算法 - 根据开关选择方形或圆形死区，独立控制
        if SQUARE_DEADZONE_SWITCH['left_stick']:
            left_x, left_y = deadzone_processor.apply_square_deadzone(left_x, left_y, 'left')
        else:
            left_x, left_y = deadzone_processor.apply_circular_deadzone(left_x, left_y, 'left')
            
        if SQUARE_DEADZONE_SWITCH['right_stick']:
            right_x, right_y = deadzone_processor.apply_square_deadzone(right_x, right_y, 'right')
        else:
            right_x, right_y = deadzone_processor.apply_circular_deadzone(right_x, right_y, 'right')

        # 应用输出增幅 - 新增步骤
        left_x, left_y = apply_output_amplifier(left_x, left_y, 'left_stick')
        right_x, right_y = apply_output_amplifier(right_x, right_y, 'right_stick')

        # 更新缓存
        stick_data_cache['left']['x'] = left_x
        stick_data_cache['left']['y'] = left_y
        stick_data_cache['right']['x'] = right_x
        stick_data_cache['right']['y'] = right_y

    except Exception as e:
        print(f"摇杆读取错误: {e}")

def process_trigger_buttons():
    """处理扳机按钮（按钮5和13）"""
    global trigger_states

    try:
        # 右扳机按钮 (ZR - 按钮5)
        zr_pressed = bool(joystick.get_button(5))
        trigger_states['right'] = 1.0 if zr_pressed else 0.0

        # 左扳机按钮 (ZL - 按钮13)
        zl_pressed = bool(joystick.get_button(13))
        trigger_states['left'] = 1.0 if zl_pressed else 0.0

    except Exception as e:
        print(f"扳机按钮读取错误: {e}")

def update_virtual_gamepad():
    """高速更新虚拟手柄"""
    global last_update_time

    while True:
        current_time = time.perf_counter()
        elapsed = current_time - last_update_time

        if elapsed >= update_interval:
            try:
                # 设置摇杆
                left = stick_data_cache['left']
                right = stick_data_cache['right']

                virtual_gamepad.left_joystick_float(left['x'], left['y'])
                virtual_gamepad.right_joystick_float(right['x'], right['y'])

                # 设置扳机
                virtual_gamepad.left_trigger_float(trigger_states['left'])
                virtual_gamepad.right_trigger_float(trigger_states['right'])

                virtual_gamepad.update()
                last_update_time = current_time

            except Exception as e:
                print(f"虚拟手柄更新错误: {e}")

        time.sleep(0.001)

# 启动高速更新线程
update_thread = threading.Thread(target=update_virtual_gamepad, daemon=True)
update_thread.start()

# 检查pyautogui可用性
try:
    import pyautogui
    USE_PYAUTOGUI = True
    print("使用pyautogui进行键盘模拟")
except ImportError:
    USE_PYAUTOGUI = False
    print("pyautogui未安装，使用pygame事件模拟")
    print("安装pyautogui: pip install pyautogui")

# 打印配置信息
print_configuration_info(JOYSTICK_PHYSICAL_LIMITS)

try:
    print(f"优化版手柄映射已启动（{UPDATE_RATE}Hz 更新率）")
    print("摇杆范围已自动识别，物理限制已补偿")
    
    # 显示独立死区配置
    left_config = DEADZONE_CONFIG['left']
    right_config = DEADZONE_CONFIG['right']
    print(f"左摇杆死区: {left_config['deadzone']:.3f}, 外环: {left_config['outer_threshold']:.2f}, 曲线: {left_config['response_curve']:.1f}")
    print(f"右摇杆死区: {right_config['deadzone']:.3f}, 外环: {right_config['outer_threshold']:.2f}, 曲线: {right_config['response_curve']:.1f}")
    
    # 显示方形死区状态
    left_status = "开启" if SQUARE_DEADZONE_SWITCH['left_stick'] else "关闭"
    right_status = "开启" if SQUARE_DEADZONE_SWITCH['right_stick'] else "关闭"
    print(f"左摇杆方形死区: {left_status}")
    print(f"右摇杆方形死区: {right_status}")
    
    # 显示输出增幅状态
    print(f"左摇杆输出增幅: {OUTPUT_AMPLIFIER['left_stick']:.1f}x")
    print(f"右摇杆输出增幅: {OUTPUT_AMPLIFIER['right_stick']:.1f}x")
    
    print("扳机按钮: ZL=按钮13, ZR=按钮5")
    
    # 打印特殊按钮配置
    for btn_id, config in SPECIAL_BUTTONS.items():
        print(f"按钮{btn_id}: {config['description']}")

    while True:
        pygame.event.pump()

        # 处理所有按钮
        num_buttons = min(joystick.get_numbuttons(), 25)
        for i in range(num_buttons):
            try:
                current_state = bool(joystick.get_button(i))
            except:
                current_state = False

            if current_state != button_states[i]:
                button_name = PHYSICAL_TO_NAME.get(i, f"Btn{i}")

                # 特殊按钮处理（如Capture按钮）
                if i in SPECIAL_BUTTONS:
                    config = SPECIAL_BUTTONS[i]
                    if current_state:
                        # 按下特殊按钮
                        if USE_PYAUTOGUI:
                            pyautogui.keyDown(config['key'])
                        else:
                            key_event = pygame.event.Event(pygame.KEYDOWN, key=getattr(pygame, f"K_{config['key']}"))
                            pygame.event.post(key_event)
                        print(f"按下: {button_name} -> 键盘{config['key'].upper()}键按下")
                    else:
                        # 释放特殊按钮
                        if USE_PYAUTOGUI:
                            pyautogui.keyUp(config['key'])
                        else:
                            key_event = pygame.event.Event(pygame.KEYUP, key=getattr(pygame, f"K_{config['key']}"))
                            pygame.event.post(key_event)
                        print(f"释放: {button_name} -> 键盘{config['key'].upper()}键释放")
                    
                    button_states[i] = current_state
                    continue

                # 普通按钮处理
                if i in PHYSICAL_TO_XBOX:
                    target = PHYSICAL_TO_XBOX[i]

                    if isinstance(target, XUSB_BUTTON):
                        # 普通按钮
                        if current_state:
                            virtual_gamepad.press_button(target)
                            print(f"按下: {button_name}")
                        else:
                            virtual_gamepad.release_button(target)
                            print(f"释放: {button_name}")

                    elif isinstance(target, str) and target in ['left_trigger', 'right_trigger']:
                        # 扳机按钮（特殊处理）
                        if current_state:
                            print(f"按下扳机: {button_name}")
                        else:
                            print(f"释放扳机: {button_name}")

                button_states[i] = current_state

        # 处理pygame事件队列（如果使用pygame模拟）
        if not USE_PYAUTOGUI:
            for event in pygame.event.get():
                # 让pygame处理我们发送的键盘事件
                if event.type in (pygame.KEYDOWN, pygame.KEYUP):
                    pass

        # 处理扳机按钮状态
        process_trigger_buttons()

        # 处理摇杆
        process_joysticks_optimized(joystick)

        time.sleep(0.001)

except KeyboardInterrupt:
    virtual_gamepad.reset()
    virtual_gamepad.update()
    pygame.quit()
    print("\n🎮 程序已退出，感谢使用！")